[{"categories":["ubuntu"],"content":"這篇是為了記錄 Ubuntu 明明 ifconfig 有 IP 卻無連線上網的問題。 在以 DHCP 作為得到 IP 的管道，但 ping 不到外網，或是 GUI 不能連上 google.com, github.com 等網址。 ifconfig and check the name of lan 上圖中，我們可以看到 lan 的名稱是 enp5s0，請根據自己要設定的 lan 名稱進行設定哦。 ","date":"2023-03-06","objectID":"/posts/ubuntu/set_network_for_ubuntu_20.04/:0:0","tags":["net","ubuntu"],"title":"排除 Ubuntu 20.04 網路問題","uri":"/posts/ubuntu/set_network_for_ubuntu_20.04/"},{"categories":["ubuntu"],"content":"燒 mac address 拿到機器時，最好先在 cmd tool 下 ifconfig 確認機器是否有 MAC address， ifconfig and check the mac address of lan 圖中的 ether 部分就是 MAC address。 如果看起來是 00:11:22:33:44:55，最好自己燒一個上去。 先關掉這個 lan sudo ifconfig enp5s0 down 加入 mac address sudo ifconfig enp5s0 hw ether AA:BB:CC:DD:EE:FF (mac address) 重新開啟 lan sudo dhclient enp5s0 ","date":"2023-03-06","objectID":"/posts/ubuntu/set_network_for_ubuntu_20.04/:1:0","tags":["net","ubuntu"],"title":"排除 Ubuntu 20.04 網路問題","uri":"/posts/ubuntu/set_network_for_ubuntu_20.04/"},{"categories":["ubuntu"],"content":"重新跟 DHCP 要一個新的 IP 在已經確認網路線有插好，Lan 燈有亮後，還可能是 DHCP 太廢 也許是其他人亂設 static IP 造成問題，這時我們就只好重啟網路，跟 DHCP 重新要一個新的 IP 一樣關閉 lan sudo ifconfig enp5s0 down 重啟 lan sudo ifconfig enp5s0 up 強迫跟 DHCP 重新要一個 IP sudo dhclient enp5s0 ","date":"2023-03-06","objectID":"/posts/ubuntu/set_network_for_ubuntu_20.04/:2:0","tags":["net","ubuntu"],"title":"排除 Ubuntu 20.04 網路問題","uri":"/posts/ubuntu/set_network_for_ubuntu_20.04/"},{"categories":["ubuntu"],"content":"Reference https://fostips.com/find-mac-address-ubuntu/ https://www.cyberciti.biz/faq/howto-linux-renew-dhcp-client-ip-address/ ","date":"2023-03-06","objectID":"/posts/ubuntu/set_network_for_ubuntu_20.04/:3:0","tags":["net","ubuntu"],"title":"排除 Ubuntu 20.04 網路問題","uri":"/posts/ubuntu/set_network_for_ubuntu_20.04/"},{"categories":["leetcode"],"content":"這篇文章介紹了如何使用 Docker 來運行 MongoDB 是一種 NoSQL 資料庫服務。文章首先解釋了 Docker 的基本概念，如容器、映像和卷，然後展示了如何從 Docker Hub 上拉取 MongoDB 的官方映像，並在本地或雲端啟動一個 MongoDB 容器。 MongoDB 是一種 NoSQL 資料庫服務，可以儲存和處理非結構化的資料。 它用 JSON 的文件作為資料單位，不需要預定義的架構。 它具有高性能、高可用性和水平擴展性的特點，適合開發各種規模和類型的應用程式。 ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:0:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"apt 更新 確認 apt 版本並更新 sudo apt update \u0026\u0026 sudo apt upgrade -y ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:1:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"新增資料夾 開好資料夾並移動進入 mkdir mongo-docker cd mongo-docker ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:2:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"尋找 docker image 尋找世界上現有的 docker image docker search mongo search all dockers of ‘mongo’ ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:3:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"下載 docker image 不要找自己麻煩，請直接 pull 官方的 image 謝謝 docker pull mongo:latest ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:4:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"檢查 image docker images ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:5:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"run image 讓 mongo 這個 image 跑起來 docker run -itd --name mongo -p 27017:27017 mongo --auth ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:6:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"進入 docker 裡的 mongo docker exec -it mongo mongosh admin 新增連線 mongo 的帳號密碼 search all dockers of ‘mongo’ ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:7:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"新增 mongoDB 帳密 db.createUser({ user:'admin',pwd:'password',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},\"readWriteAnyDatabase\"]}); ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:8:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"驗證 mongoDB 帳密 db.auth('admin', 'password') ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:9:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"檢查 mongoDB 看最後一眼 db show dbs ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:10:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"離開 docker 內部 離開這個 docker 裡的 mongoDB exit ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:11:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"打開 27017 port sudo ufw allow 27017 可以直接用 Windows PC 的 IP 進行遠端連線 ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:12:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"MongoDB compass 如果有下載 MongoDB compass，可以直接用輸入以下字串 mongodb://admin:password@\u003clinux server IP\u003e/ ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:12:1","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"telnet telnet \u003clinux server IP\u003e 27017 ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:12:2","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"重啟 mongo docker docker-ps check process of mongo docker docker start \u003ccontainer id\u003e ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:13:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["leetcode"],"content":"清除已經停止的 docker docker container prune ","date":"2023-02-27","objectID":"/posts/docker/run_mongodb_in_docker/:14:0","tags":["mongodb","docker"],"title":"在 Docker 裡面安裝 Mongo DB","uri":"/posts/docker/run_mongodb_in_docker/"},{"categories":["ubuntu"],"content":"根據這篇給新手的 GCC 安裝教學，想到我從來沒有自己裝過 GCC，以前 linux 都是直接用 server 上人家裝好的環境，Windows 直接用 CLion 或 Visual Studio，第一次想在自己的 ubuntu 上安裝 GCC，想不到竟然折騰好久 QQ ","date":"2023-01-23","objectID":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/:0:0","tags":["C","ubuntu"],"title":"Ubuntu 20.04 安裝 GCC 採坑紀錄","uri":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/"},{"categories":["ubuntu"],"content":"安裝 GCC sudo apt get update sudo apt install GCC 很簡單就完成了 ","date":"2023-01-23","objectID":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/:1:0","tags":["C","ubuntu"],"title":"Ubuntu 20.04 安裝 GCC 採坑紀錄","uri":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/"},{"categories":["ubuntu"],"content":"編譯第一次: fatal error: stdio.h: No such file or directory eyzim@MC13:~/code/first-c$ GCC hello.c hello.c:2:10: fatal error: stdio.h: No such file or directory 2 | #include \u003cstdio.h\u003e | ^~~~~~~~~ compilation terminated. lib 沒有引入耶 看看這篇 GCC fatal error: stdio.h: No such file or directory，少了標準庫，應該是之前 GCC 裡面沒包含到 ","date":"2023-01-23","objectID":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/:2:0","tags":["C","ubuntu"],"title":"Ubuntu 20.04 安裝 GCC 採坑紀錄","uri":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/"},{"categories":["ubuntu"],"content":"回來安裝 g++ 總行了吧，反正一樣都能 compile C / C++ 安裝 g++ sudo apt install libc6-dev g++ 得到 eyzim@MC13:~/code/first-c$ sudo apt install libc6-dev g++ Reading package lists... Done Building dependency tree Reading state information... Done Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: libc6-dev : Depends: libc6 (= 2.31-0ubuntu9.7) but 2.31-0ubuntu9.9 is to be installed E: Unable to correct problems, you have held broken packages. 不信邪，直接安裝 build-essential 總行了吧 sudo apt get install build-essential 又失敗 eyzim@MC13:~/code/first-c$ sudo apt get install build-essential Reading package lists... Done Building dependency tree Reading state information... Done Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: build-essential : Depends: libc6-dev but it is not going to be installed or libc-dev Depends: g++ (\u003e= 4:9.2) but it is not going to be installed E: Unable to correct problems, you have held broken packages. 看了一下，應該是 apt 的來源出現問題，但現在在牆內，不想亂動他的話，該怎麼修正呢? → 用 aptitude sudo apt install aptitude sudo aptitude install g++ aptitude 魔法就會自己運作啦 eyzim@MC13:~/code/first-c$ sudo aptitude install g++ The following NEW packages will be installed: g++ g++-9{a} libc-dev-bin{a} libc6-dev{ab} libcrypt-dev{a} libstdc++-9-dev{a} linux-libc-dev{a} manpages-dev{a} 0 packages upgraded, 8 newly installed, 0 to remove and 0 not upgraded. Need to get 16.2 MB of archives. After unpacking 77.3 MB will be used. The following packages have unmet dependencies: libc6-dev : Depends: libc6 (= 2.31-0ubuntu9.7) but 2.31-0ubuntu9.9 is installed The following actions will resolve these dependencies: Keep the following packages at their current version: 1) g++ [Not Installed] 2) g++-9 [Not Installed] 3) libc6-dev [Not Installed] 4) libstdc++-9-dev [Not Installed] Accept this solution? [Y/n/q/?] **n** 這邊記得選 n Breaks: hurd (\u003c 1:0.9.git20170910-1), iraf-fitsutil (\u003c 2018.07.06-4), libtirpc1 (\u003c 0.2.3), locales (\u003c 2.31), locales:i386 (\u003c 2.31), locales-all (\u003c 2.31), locales-all:i386 (\u003c 2.31), nocache (\u003c 1.1-1~), nscd (\u003c 2.31), nscd:i386 (\u003c 2.31), r-cran-later (\u003c 0.7.5+dfsg-2), wcc (\u003c 0.0.2+dfsg-3), libc6:i386 (!= 2.31-0ubuntu9.7) Replaces: libc6-amd64, libc6-amd64:i386, libc6-amd64:x32, libc6-amd64:x32-i386-cross, libc6-amd64:i386-x32-cross, libc6:i386 (\u003c 2.31-0ubuntu9.7) Description: GNU C Library: Shared libraries Contains the standard libraries that are used by nearly all programs on the system. This package includes shared versions of the standard C library and the standard math library, as well as many others. Homepage: https://www.gnu.org/software/libc/libc.html This action was selected because libc6-dev depends upon libc6 (= 2.31-0ubuntu9.7). Enter \"r 1\" to prevent this action from appearing in new solutions. Enter \"a 1\" to require that new solutions include this action if possible. Accept this solution? [Y/n/q/?] a 1 選擇 a 1 剩下就是問你是否願意安裝檔案，直接 yes 過關 完成，用自己安裝的編譯器編譯自己寫的 C code 囉~ Source code: // hello.c #include \u003cstdio.h\u003e int main() { printf(\"Hello, my first c code on my ubuntu :)\\n\"); return 0; } 編譯 GCC hello.c -o mycode 檢查一下有沒有產生檔案 eyzim@MC13:~/code/first-c$ ll total 32 drwxrwxr-x 2 eyzim eyzim 4096 Jan 23 02:31 ./ drwxrwxr-x 3 eyzim eyzim 4096 Jan 23 02:27 ../ -rw-rw-r-- 1 eyzim eyzim 109 Jan 23 02:27 hello.c -rwxrwxr-x 1 eyzim eyzim 16696 Jan 23 02:31 mycode* 執行它 eyzim@MC13:~/code/first-c$ ./mycode Hello, my first c code on my ubuntu :) 自己裝的 [[GCC]] 用起來真香(誤 ","date":"2023-01-23","objectID":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/:3:0","tags":["C","ubuntu"],"title":"Ubuntu 20.04 安裝 GCC 採坑紀錄","uri":"/posts/ubuntu/build_your_gcc_environment_on_ubuntu_with_error/"},{"categories":["nodejs"],"content":"當程式內容越來越多，我們通常會把原本寫在同一個檔案的 code，分割成許多個文件，不用一直上下滾動滑鼠，方便查看內容。 因此，就遇到了這樣的問題：export 和 import 首先，我們會有一個很長很長的 index.js /* index.js */ let saySomething = (input) =\u003e { console.log(`\\nI would like to say ${input} :)\\n`); }; let main = (talk) =\u003e { saySomething(talk); }; main(process.argv[2]); \u003e node .\\index.js exportSomething Debugger attached. I would like to say exportSomething :) Waiting for the debugger to disconnect... 目前這樣看起來沒甚麼問題，但如果同一支 index.js 裡面塞了 1000 個 function，每次光是尋找相同的變數就要花很多時間查看，這時候就要把 index.js 依照各個 function 功能拆分許多檔案了。 我們的目標是將 saySomething 這個 function 移到別的檔案。 ","date":"2022-12-19","objectID":"/posts/nodejs/learn_nodejs_import_export/:0:0","tags":["nodejs","javascript"],"title":"[NodeJS] Import 和 export 程式碼","uri":"/posts/nodejs/learn_nodejs_import_export/"},{"categories":["nodejs"],"content":"分割 首先，先來拆解檔案 index.js 變成 /* index.js */ let main = (talk) =\u003e { saySomething(talk); }; main(process.argv[2]); 新增另一個檔案 say.js /* say.js */ let saySomething = (input) =\u003e { console.log(`\\nI would like to say ${input} :)\\n`); }; ","date":"2022-12-19","objectID":"/posts/nodejs/learn_nodejs_import_export/:1:0","tags":["nodejs","javascript"],"title":"[NodeJS] Import 和 export 程式碼","uri":"/posts/nodejs/learn_nodejs_import_export/"},{"categories":["nodejs"],"content":"export 再來是把 say.js 中的 saySomething 這個 function export export module.exports = { functionA, functionB }; say.js 加入 export /* say.js */ let saySomething = (input) =\u003e { console.log(`\\nI would like to say ${input} :)\\n`); }; module.exports = { saySomething }; ","date":"2022-12-19","objectID":"/posts/nodejs/learn_nodejs_import_export/:2:0","tags":["nodejs","javascript"],"title":"[NodeJS] Import 和 export 程式碼","uri":"/posts/nodejs/learn_nodejs_import_export/"},{"categories":["nodejs"],"content":"import 再來就要 import 啦，根據 mdn 的教學 這時的 code 長這樣 index.js /* index.js */ import { saySomething } from \"./say\"; let main = (talk) =\u003e { saySomething(talk); }; main(process.argv[2]); say.js /* say.js */ let saySomething = (input) =\u003e { console.log(`\\nI would like to say ${input} :)\\n`); }; module.exports = { saySomething }; 然後就跳出了 \u003e node .\\index.js exportSomething Debugger attached. (node:26088) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension. (Use `node --trace-warnings ...` to show where the warning was created) Waiting for the debugger to disconnect... D:\\eyzim\\index.js:1 import { saySomething } from \"./say\"; ^^^^^^ SyntaxError: Cannot use import statement outside a module at Object.compileFunction (node:vm:360:18) at wrapSafe (node:internal/modules/cjs/loader:1088:15) at Module.\\_compile (node:internal/modules/cjs/loader:1123:27) at Module.\\_extensions..js (node:internal/modules/cjs/loader:1213:10) at Module.load (node:internal/modules/cjs/loader:1037:32) at Module.\\_load (node:internal/modules/cjs/loader:878:12) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12) at node:internal/main/run_main_module:23:47 outside a module 是甚麼??? 靠關鍵字大法：在 package.json 中加入 \"type\": \"module\", 沒用。 還是一樣 outside a module。 每個檔案是一個單獨的 module，如果我想要在 index.js 中使用 say.js，必須將他們 bundle / 捆包起來，目前看起來只是單獨執行一個檔案而已。 ","date":"2022-12-19","objectID":"/posts/nodejs/learn_nodejs_import_export/:3:0","tags":["nodejs","javascript"],"title":"[NodeJS] Import 和 export 程式碼","uri":"/posts/nodejs/learn_nodejs_import_export/"},{"categories":["nodejs"],"content":"import 改成 require 那麼，我們換個做法！ (記得把剛剛在 package.json 中的修改移除) export const { functionA, functionB } = require(\"./subFile\"); index.js /* index.js */ const { saySomething } = require(\"./say\"); let main = (talk) =\u003e { saySomething(talk); }; main(process.argv[2]); say.js /* say.js */ let saySomething = (input) =\u003e { console.log(`\\nI would like to say ${input} :)\\n`); }; module.exports = { saySomething }; 終於成功了，卡在這種問題上很困擾呀。 結論就是 modules.export = { A } 配上 const { A } = require(\"./檔案A\") ","date":"2022-12-19","objectID":"/posts/nodejs/learn_nodejs_import_export/:4:0","tags":["nodejs","javascript"],"title":"[NodeJS] Import 和 export 程式碼","uri":"/posts/nodejs/learn_nodejs_import_export/"},{"categories":["nodejs"],"content":"Reference MDN export MDN import ","date":"2022-12-19","objectID":"/posts/nodejs/learn_nodejs_import_export/:5:0","tags":["nodejs","javascript"],"title":"[NodeJS] Import 和 export 程式碼","uri":"/posts/nodejs/learn_nodejs_import_export/"},{"categories":["java"],"content":"SMTP 協定 Info SMTP（Simple Mail Transfer Protocol）是大多數電子郵件系統所需的網路協定，允許電子郵件在網際網路上進行傳輸，每當使用者端傳送郵件時，將電子郵件從一個郵件伺服器傳送到另一個郵件伺服器。 最基礎版本的 JavaMail，設定 host, port 和是否使用認證即可。 Properties properties = new Properties(); properties.put(\"mail.smtp.host\", smtpServer); properties.put(\"mail.smtp.port\", smtpPort); properties.put(\"mail.smtp.auth\", authentication ? \"true\" : \"false\"); properties.put(\"mail.smtp.starttls.enable\", tls ? \"true\" : \"false\"); if (authentication) { session = Session.getInstance(properties, new javax.mail.Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(adminAccount, adminPassword); } }); } else { session = Session.getInstance(properties, null); } ","date":"2022-11-21","objectID":"/posts/java/javax_mail_for_gmail_and_mailhog/:1:0","tags":["java","tls"],"title":"[Java] JavaMail 使用 Gmail 和 Mailhog 作為 SMTP Server","uri":"/posts/java/javax_mail_for_gmail_and_mailhog/"},{"categories":["java"],"content":"Gmail Gmail 需要設定 App service 專用密碼，不能直接輸入登入用帳號密碼，操作說明 Client 端設定參數: Server Host: smtp.gmail.com Server Port: 465 Account: abc@gmail.com Password: 根據第一點 Gmail 要求所產生的十六位專用密碼 Auth 和 TLS 必須開啟 到了 Gmail，因為 Gmail 採用 TLS 加密，我們還需要加入 socket factory if(TLS) { properties.put(\"mail.smtp.socketFactory.port\", smtpPort); properties.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\"); properties.put(\"mail.smtp.socketFactory.fallback\", \"false\"); MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); properties.put(\"mail.smtp.ssl.trust\", \"*\"); properties.put(\"mail.smtp.ssl.socketFactory\", sf); } ","date":"2022-11-21","objectID":"/posts/java/javax_mail_for_gmail_and_mailhog/:2:0","tags":["java","tls"],"title":"[Java] JavaMail 使用 Gmail 和 Mailhog 作為 SMTP Server","uri":"/posts/java/javax_mail_for_gmail_and_mailhog/"},{"categories":["java"],"content":"MailHog MailHog 是一個位於本機端的 SMTP Server 及 Client，他會接收其他 App (我們送出的) SMTP request，接收後不會轉發，而是送到 MailHog 自己架設的 Web page (可以想像成 Gmail client 端)，可以看到我們送出的 SMTP request 接收到信件時的模擬畫面。 先在本機端 clone mailhog 的 docker docker pull mailhog/mailhog Run docker docker run -d -p 1025:1025 -p 8025:8025 mailhog/mailhog Port 1025 作為 SMTP Server 收聽端，Port 8025 作為 SMTP Mail web page 的呈現端口 開啟 docker 需要使用的兩個端口權限 sudo ufw allow 1025 sudo ufw allow 8025 確認開啟後，可以到 localhost:8025 檢查 web page 是否開啟 ","date":"2022-11-21","objectID":"/posts/java/javax_mail_for_gmail_and_mailhog/:3:0","tags":["java","tls"],"title":"[Java] JavaMail 使用 Gmail 和 Mailhog 作為 SMTP Server","uri":"/posts/java/javax_mail_for_gmail_and_mailhog/"},{"categories":["java"],"content":"Reference Mailhog docker: https://hub.docker.com/r/mailhog/mailhog/ ","date":"2022-11-21","objectID":"/posts/java/javax_mail_for_gmail_and_mailhog/:4:0","tags":["java","tls"],"title":"[Java] JavaMail 使用 Gmail 和 Mailhog 作為 SMTP Server","uri":"/posts/java/javax_mail_for_gmail_and_mailhog/"},{"categories":["Git"],"content":" 在 GitHub 上建立專案 test 產生後會在主頁面看到這個提示 回到本機端，走到要上傳的資料夾中 新增 .git 紀錄 git init 把要記錄的檔案 作業 加入暫存區 交作業區 (staged) 一一輸入檔案名稱的方式： git add index.js 我沒耐心一次龍齁ㄌㄨㄟ ˋ 的方式： git add . 放入暫存區後，將暫存區 交作業區 的檔案 作業 交給 commit 小老師 git commit -m \"[commit msg]\" 遠端連線 GitHub 上的 Git git remote add origin https://github.com/eyzim/test.git 本機端的 Git commit 小老師 推到 GitHub 老師 那邊的 Git git push --set-upstream origin master ","date":"2022-10-25","objectID":"/posts/push_my_project_to_github/:0:0","tags":["Git","GitHub"],"title":"[Git] 新增專案到 GitHub","uri":"/posts/push_my_project_to_github/"},{"categories":["nodejs"],"content":"開始之前 這篇文章在環境設定的部分是以 Windows 做為示範，若使用 MacOS，請直接跳至 建立乾淨的專案 確定電腦環境中有安裝這些: 安裝軟體 Visual Studio Code Windows Powershell NodeJS 其中 VSCode 可以是任何其他你已經相當習慣的文字編輯軟體 Word。 ","date":"2022-10-18","objectID":"/posts/nodejs/start-our-first-nodejs-project/:1:0","tags":["nodejs"],"title":"[NodeJS] 程式麻瓜的第一個 nodeJS 專案","uri":"/posts/nodejs/start-our-first-nodejs-project/"},{"categories":["nodejs"],"content":"安裝 Visual Studio Code 直接安裝 stable version，一直點確定確定確定就安裝好了。 Visual Studio Code Windows Powershell 則可以在 Windows 左下角搜尋欄中輸入 “PowerShell” 找到。 PowerShell 下載 node.js LTS 版本 NodeJS ","date":"2022-10-18","objectID":"/posts/nodejs/start-our-first-nodejs-project/:1:1","tags":["nodejs"],"title":"[NodeJS] 程式麻瓜的第一個 nodeJS 專案","uri":"/posts/nodejs/start-our-first-nodejs-project/"},{"categories":["nodejs"],"content":"建立乾淨的專案 開啟 VSCode，開啟一個乾淨的資料夾。 接下來我們會在這個資料夾中新增很多小專案，所以再新增第一個麻瓜資料夾，萬一被麻瓜法術搞砸，刪掉這個資料夾就一切和平了 開啟 VSCode 的 terminal 在 VSCode 乾淨的畫面上按 ctrl + p 輸入 \u003eterminal 選擇 JavaScript Debug Terminal Open the terminal of VSCode 此時 VSCode 視窗下半部就會彈出小視窗了視窗了 This is the terminal of VSCode 新增子資料夾 first-nodejs-app # 新增資料夾 mkdir first-nodejs-app # 移動到資料夾中 cd first-nodejs-app ","date":"2022-10-18","objectID":"/posts/nodejs/start-our-first-nodejs-project/:2:0","tags":["nodejs"],"title":"[NodeJS] 程式麻瓜的第一個 nodeJS 專案","uri":"/posts/nodejs/start-our-first-nodejs-project/"},{"categories":["nodejs"],"content":"開始 NodeJS 的大門 第一個檔案 index.js touch index.js 建構整個網頁的配置檔 npm 管理工具 nodejs 中，所有需要的延伸工具包，都是由 npm 這個指令所管理 npm init 接著會有許多問你是不是對不對的問題，如果覺得麻煩，也可以這樣 npm init -y 所有問題都直接代替你回答 yes 了 安裝我們的第一個工具包 這個工具包讓我們執行 nodejs 時，不用每次修改後都要重啟 nodejs，永遠會為你更新到現在修改完的成果 npm i express npm i path npm i ejs 這裡的 -g 代表著安裝到本機端，如果不要加上 -g，每次我們新增專案時都要再一次安裝這個工具 npm i -g nodemon 嘗試使用 nodemon nodemon index.js 這時出現了 first-nodejs-app\u003e nodemon .\\index.js nodemon : 因為這個系統上已停用指令碼執行，所以無法載入 C:\\Users\\eyzim\\AppData\\Roaming\\npm\\nodemon.ps1 檔案。如需詳細資 訊，請參閱 about_Execution_Policies，網址為 https:/go.microsoft.com/fwlink/?LinkID=135170。 位於 線路:1 字元:1 + nodemon .\\index.js + ~~~~~~~ + CategoryInfo : SecurityError: (:) [], PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess ","date":"2022-10-18","objectID":"/posts/nodejs/start-our-first-nodejs-project/:3:0","tags":["nodejs"],"title":"[NodeJS] 程式麻瓜的第一個 nodeJS 專案","uri":"/posts/nodejs/start-our-first-nodejs-project/"},{"categories":["nodejs"],"content":"PowerShell 處理權限問題 最後一行寫著 UnauthorizedAccess，看起來是權限不足 一樣在 Windows 畫面左下角搜尋 PowerShell 以系統管理員身分打開 Windows PowerShell Run PowerShell as administrator 設置權限，選擇可以不需要簽署直接執行本機端的腳本檔案 Set-ExecutionPolicy RemoteSigned 看到 Log 跑出 PS C:\\Windows\\system32\u003e Set-ExecutionPolicy RemoteSigned 執行原則變更 執行原則有助於防範您不信任的指令碼。如果變更執行原則，可能會使您接觸到 about_Execution_Policies 說明主題 (網址為 https:/go.microsoft.com/fwlink/?LinkID=135170) 中所述的安全性風險。您要變更執行原則嗎? [Y] 是(Y) [A] 全部皆是(A) [N] 否(N) [L] 全部皆否(L) [S] 暫停(S) [?] 說明 (預設值為 \"N\"): 選擇 y 同意 確認權限設置是否成功 Get-ExecutionPolicy PS C:\\Windows\\system32\u003e Get-ExecutionPolicy RemoteSigned 回到 VSCode，再次輸入 nodemon index.js ","date":"2022-10-18","objectID":"/posts/nodejs/start-our-first-nodejs-project/:3:1","tags":["nodejs"],"title":"[NodeJS] 程式麻瓜的第一個 nodeJS 專案","uri":"/posts/nodejs/start-our-first-nodejs-project/"},{"categories":["nodejs"],"content":"編輯 index.js // use express const express = require(\"express\"); const app = express(); // use ejs const path = require(\"path\"); ejs = require(\"ejs\"); app.set(\"view engine\", \"ejs\"); app.set(\"views\", path.join(__dirname, \"/views\")); app.get(\"/\", (req, res) =\u003e { res.send(\"HOME PAGE\"); }); app.listen(\"3000\", () =\u003e { console.log(\"listening port 3000\"); }); 讓檔案開始運作 nodemon index.js 會在 terminal 看到 listening port 3000 Run index.js ","date":"2022-10-18","objectID":"/posts/nodejs/start-our-first-nodejs-project/:4:0","tags":["nodejs"],"title":"[NodeJS] 程式麻瓜的第一個 nodeJS 專案","uri":"/posts/nodejs/start-our-first-nodejs-project/"},{"categories":["leetcode"],"content":"在看這題題目之前，可以先試試看相似題 Power of three 哦！ ","date":"2022-08-22","objectID":"/posts/leetcode/leetcode_342_power_of_four/:0:0","tags":["easy","c++","recursion","bit manipulation","math"],"title":"LeetCode 342. Power of Four 解題紀錄","uri":"/posts/leetcode/leetcode_342_power_of_four/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == $4^x$. Example 1: Input: n = 16 Output: true Example 2: Input: n = 5 Output: false Example 3: Input: n = 1 Output: true Constraints: $-2^{31} \\leq x \\leq 2^{31}-1$ Follow up: Could you solve it without loops/recursion? ","date":"2022-08-22","objectID":"/posts/leetcode/leetcode_342_power_of_four/:1:0","tags":["easy","c++","recursion","bit manipulation","math"],"title":"LeetCode 342. Power of Four 解題紀錄","uri":"/posts/leetcode/leetcode_342_power_of_four/"},{"categories":["leetcode"],"content":"解法一： 使用以前學過的 $log{_b}{a}$ $ \\ = log*{10}{a} \\div log*{10}{b}$ $ \\ = \\frac{log{a}}{log{b}}$， 舉一反三， $log_{4}{n}$ $ \\ = log*{10}{n} \\div log*{10}{4}$ $ \\ = log{n} \\div log4 $ $ \\ = \\frac{log{n}}{log{4}}$ 檢查做完 $log$ 之後是否為整數，若是整數，則 n 為 4 的次方；反之，則否。 class Solution { public: bool isPowerOfFour(int n) { if(n \u003c 1) return 0; double check = log(n)/log(4); // 驗證是否為整數 if(check - (int)check == 0) return 1; return 0; } }; Time complexity: $\\mathcal{O}(\\log N)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-08-22","objectID":"/posts/leetcode/leetcode_342_power_of_four/:1:1","tags":["easy","c++","recursion","bit manipulation","math"],"title":"LeetCode 342. Power of Four 解題紀錄","uri":"/posts/leetcode/leetcode_342_power_of_four/"},{"categories":["leetcode"],"content":"解法二： 遞迴檢查是否為 4 的次方及是否可被 4 整除 bool isPowerOfFour(int n) { if(n \u003c 1) { return 0; } if(n == 1) { return 1; } // 若可被 4 除盡 \u0026\u0026 是 4 的次方 return !(n%4) \u0026\u0026 isPowerOfFour(n/4); } Time complexity: $\\mathcal{O}(\\log N)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-08-22","objectID":"/posts/leetcode/leetcode_342_power_of_four/:1:2","tags":["easy","c++","recursion","bit manipulation","math"],"title":"LeetCode 342. Power of Four 解題紀錄","uri":"/posts/leetcode/leetcode_342_power_of_four/"},{"categories":["leetcode"],"content":"Reference stackoverflow - Calculate the log base n stackoverflow - Checking if float is an integer ","date":"2022-08-22","objectID":"/posts/leetcode/leetcode_342_power_of_four/:2:0","tags":["easy","c++","recursion","bit manipulation","math"],"title":"LeetCode 342. Power of Four 解題紀錄","uri":"/posts/leetcode/leetcode_342_power_of_four/"},{"categories":["leetcode"],"content":"題目 Problem International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: ‘a’ maps to “.-”, ‘b’ maps to “-…”, ‘c’ maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. Example 1: Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"] Output: 2 Explanation: The transformation of each word is: “gin” -\u003e “–…-.” “zen” -\u003e “–…-.” “gig” -\u003e “–…–.” “msg” -\u003e “–…–.” There are 2 different transformations: “–…-.” and “–…–.”. Example 2: Input: words = [\"a\"] Output: 1 Constraints: 1 $\\leq$ words.length $\\leq$ 100 1 $\\leq$ words[i].length $\\leq$ 12 words[i] consists of lowercase English letters. ","date":"2022-08-15","objectID":"/posts/leetcode/leetcode_804_unique_morse_code_words/:1:0","tags":["easy","c++","array","hash table","string"],"title":"LeetCode 804. Unique Morse Code Words 解題紀錄","uri":"/posts/leetcode/leetcode_804_unique_morse_code_words/"},{"categories":["leetcode"],"content":"想法 題目已經給好 a 到 z 的對照表，新增一個陣列，對照存入後，只要依照題目給予的字串即可生成替代的摩斯密碼。 最後再存入 set 中，若無重複即存入，計算 set 中個數就可以知道有幾組未重複組合。 英文 char 如何轉成數字 看這邊 或是下面的小抄 char to int: a[i] - 'a' ps: 這個問題好像被我 google 了 n 遍了 🤣 ","date":"2022-08-15","objectID":"/posts/leetcode/leetcode_804_unique_morse_code_words/:2:0","tags":["easy","c++","array","hash table","string"],"title":"LeetCode 804. Unique Morse Code Words 解題紀錄","uri":"/posts/leetcode/leetcode_804_unique_morse_code_words/"},{"categories":["leetcode"],"content":"解法 class Solution { public: int uniqueMorseRepresentations(vector\u003cstring\u003e\u0026 words) { // 密碼對照表 string mp[26] = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; set\u003cstring\u003e produce_code; // 一一讀入 string vector 中的每個字串 for(auto word:words) { string comb = \"\"; // 一一讀入字串的字母 for(auto i:word) { // 將 char 轉為數字，查表查出正確翻譯 comb += mp[i-'a']; } // 存入 set 中確認有幾組未重複組合 produce_code.insert(comb); } return produce_code.size(); } }; Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2022-08-15","objectID":"/posts/leetcode/leetcode_804_unique_morse_code_words/:3:0","tags":["easy","c++","array","hash table","string"],"title":"LeetCode 804. Unique Morse Code Words 解題紀錄","uri":"/posts/leetcode/leetcode_804_unique_morse_code_words/"},{"categories":["git"],"content":"「記得把 code commit 上 Git 啊！」 聽到 Git 的時候，通常腦袋團團轉，到底要怎麼樣才能快速上手呢? ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:0:0","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"Learning Git Branching Learning Git Branching 是 GitHub 上很有名的專案，用視覺化的練習，讓人不用真的開一個 reposity 也能清楚明瞭 rebase、cherry-pick，玩到後面關卡時，才發現每題都想用 cherry-pick 秒解啊 😄 ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:1:0","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"小抄 ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:0","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"最最最基礎 git add . git commit -m \"一些標籤\" git push ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:1","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"建立分支 新增分支並且移動到那個分支 git checkout -b \u003c分支的名字\u003e 移動到那個分支 git checkout \u003c分支的名字\u003e 查看現在分支位置 git branch git push origin newBranch ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:2","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"將版本 merge 到主枝幹 在某一個 branch 上 git rebase master 把 branch 的所有紀錄合併到 master 上囉 把別的 branch 的 comit 移動成目前的最新 commit git branch -f \u003cbranch\u003e \u003ccommitID\u003e ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:3","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"復原 往上走兩格 git reset HEAD~2 回復到某 id 並新增相同的模樣節點 git revert commitID ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:4","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"回到上次 commit 的版本 重設 local 端的修改，回復至上次 commit 完當下的面貌 git reset --hard HEAD 回到上 n 次的版本 git reset --hard HEAD~n 取消剛剛的 commit，把 commit 收回，回到已經修改過的檔案，但只有 git add 的狀態 git reset –soft HEAD ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:5","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"修改記錄檔 在現在的 head 後面加上 v3 v5 兩個 commit (不用同分支) git cherry-pick v3 v5 開一個 VIM 直接編輯 git rebase -i HEAD~5 ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:2:6","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["git"],"content":"Reference ","date":"2022-05-09","objectID":"/posts/git-cheetsheet/:3:0","tags":["Git"],"title":"【Git】初學者筆記","uri":"/posts/git-cheetsheet/"},{"categories":["Java"],"content":"以前寫 C++ 時就有用過 CLion 這個強大又美麗的產品，突然被要求要寫 Java web application，就想要試試 IntelliJ 啦 (絕對不能說 Eclipse 不得我心哈哈) Jet Brains 家的產品迭代快速，來份熱騰騰的安裝文囉。 ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:0:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"1. 安裝 Java SDK ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:1:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"2. 安裝 IntelliJ IDEA → 他們現在很先進，都會自己帶入路徑免煩惱 🙂 ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:2:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"3. 下載 Tomcat 才能開啟 web viewer 下載後解壓縮至此，確定資料夾名稱是 apache-tomcat-版本號 ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:3:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"4. 打開 IntelliJ ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:4:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"5. 點擊 New Project ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:5:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"6. 選擇新增 Java Enterprise 專案 ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:6:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"7. 點選下一步，就完成專案建置啦~ ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:7:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"8. 瀏覽器自己打開！ 右上角箭頭按下去，Run 專案後，console 會有一些 apache 跑起來的 log，接著瀏覽器就會自己打開 ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:8:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["Java"],"content":"Reference https://juejin.cn/post/6844904020780253191 ","date":"2022-05-02","objectID":"/posts/java_web_with_intellij_2022/:9:0","tags":["Java","install","setup","web"],"title":"[WEB] 用 IntelliJ 開啟第一個 Java web","uri":"/posts/java_web_with_intellij_2022/"},{"categories":["leetcode"],"content":"題目 Problem You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts. Example 1: Input: s = \"ababcbacadefegdehijhklij\" Output: [9,7,8] Explanation: The partition is “ababcbaca”, “defegde”, “hijhklij”. This is a partition so that each letter appears in at most one part. A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits s into less parts. Example 2: Input: s = \"eccbbbbdec\" Output: [10] Constraints: 1 $\\leq$ s.length $\\leq$ 500 s consists of lowercase English letters. ","date":"2022-03-21","objectID":"/posts/leetcode/leetcode_763_partition_labels/:1:0","tags":["hash table","two pointers","string","greedy","easy","c++"],"title":"LeetCode 763. Partition Labels 解題紀錄","uri":"/posts/leetcode/leetcode_763_partition_labels/"},{"categories":["leetcode"],"content":"想法 以 Example 1 為例子，s[0] 的字元 a 在字串中最後一次出現在 s[8]，只要從第一個到第八個字元最後一次出現都是在 s[8] 之前，我們就將這一字串分割為一組子字串。 pos 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 字元 a b a b c b a c a d e f e g d e h i j h k l i j 字元最後出現位置 8 5 8 5 7 5 8 7 8 14 15 11 15 13 14 15 19 22 23 19 20 21 22 23 從範例可以知道，在走到 s[8] 之前，s[0]~s[7] 的最後出現位置都小於 8，換言之，以 s[8] 最為分界點，將 s[0]~s[8] 分為一個子字串。 另外注意一點是，題目要求返回子字串長度。 ","date":"2022-03-21","objectID":"/posts/leetcode/leetcode_763_partition_labels/:2:0","tags":["hash table","two pointers","string","greedy","easy","c++"],"title":"LeetCode 763. Partition Labels 解題紀錄","uri":"/posts/leetcode/leetcode_763_partition_labels/"},{"categories":["leetcode"],"content":"解法 ","date":"2022-03-21","objectID":"/posts/leetcode/leetcode_763_partition_labels/:3:0","tags":["hash table","two pointers","string","greedy","easy","c++"],"title":"LeetCode 763. Partition Labels 解題紀錄","uri":"/posts/leetcode/leetcode_763_partition_labels/"},{"categories":["leetcode"],"content":"解法一 string.find() 平常常見的 string.find() 是正序搜尋，希望能倒序搜尋則使用 string.rfind()。 vector\u003cint\u003e partitionLabels(string s) { vector\u003cint\u003e ans; // cut 紀錄最大的子字串最後一次出現位置、pre 紀錄下一個字串的起始位置 auto cut = INT_MIN, pre = 0; for(auto i=0; i\u003cs.size(); i++) { // 檢查是否有更遠的字串最後一次出現位置，若有，則更新位置 cut = max((int)s.rfind(s[i]), cut); // 如果現在位置就是最遠的字串最後一次出現位置 aka 切割點，則切成子字串 // 並記錄下一字串的起始位置 if(i == cut) { ans.push_back(cut-pre+1); pre = cut + 1; } } return ans; } rfind() 本身就是 $\\mathcal{O}(n)$，每次都進行運算，使整個演算法的時間複雜度為 $\\mathcal{O}(n^2)$. Time complexity: $\\mathcal{O}(n^2)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-03-21","objectID":"/posts/leetcode/leetcode_763_partition_labels/:3:1","tags":["hash table","two pointers","string","greedy","easy","c++"],"title":"LeetCode 763. Partition Labels 解題紀錄","uri":"/posts/leetcode/leetcode_763_partition_labels/"},{"categories":["leetcode"],"content":"解法二 vector\u003cint\u003e partitionLabels(string s) { vector\u003cint\u003e ans; vector\u003cint\u003e alp(26, 0); // cut 紀錄最大的子字串最後一次出現位置、lastPos 紀錄下一個字串的起始位置 int cut = -1, lastPos = 0; // 覆蓋存入每一個 char 的最後出現位置 for(auto i=0; i\u003cs.size(); i++) { alp[s[i]-'a'] = i; } for(auto i=0; i\u003cs.size(); i++) { // 檢查是否有更遠的字串最後一次出現位置，若有，則更新位置 cut = max(cut, alp[s[i]-'a']); // 如果現在位置就是最遠的字串最後一次出現位置 aka 切割點，則切成子字串 // 並記錄下一字串的起始位置 if(cut == i) { ans.push_back(cut - lastPos + 1); lastPos = cut + 1; } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. 這題是多年前寫過，今天變成 LeetCode 每日選題，回去看以前的 code，發現那個答案是不知道哪裡查到直接抄的 XD 看著自己默默地也成長了一點點有點欣慰，已經買到回台灣的機票了，準備回去找工作了！ ","date":"2022-03-21","objectID":"/posts/leetcode/leetcode_763_partition_labels/:3:2","tags":["hash table","two pointers","string","greedy","easy","c++"],"title":"LeetCode 763. Partition Labels 解題紀錄","uri":"/posts/leetcode/leetcode_763_partition_labels/"},{"categories":["leetcode"],"content":"Reference https://www.cplusplus.com/reference/string/string/rfind/ https://vimsky.com/zh-tw/examples/usage/stdstringrfind-in-c-with-examples.html ","date":"2022-03-21","objectID":"/posts/leetcode/leetcode_763_partition_labels/:4:0","tags":["hash table","two pointers","string","greedy","easy","c++"],"title":"LeetCode 763. Partition Labels 解題紀錄","uri":"/posts/leetcode/leetcode_763_partition_labels/"},{"categories":["leetcode"],"content":"題目 Problem You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order. Return the array after sorting it. Example 1: Input: arr = [0,1,2,3,4,5,6,7,8] Output: [0,1,2,4,8,3,5,6,7] Explantion: [0] is the only integer with 0 bits. [1,2,4,8] all have 1 bit. [3,5,6] have 2 bits. [7] has 3 bits. The sorted array by bits is [0,1,2,4,8,3,5,6,7] Example 2: Input: arr = [1024,512,256,128,64,32,16,8,4,2,1] Output: [1,2,4,8,16,32,64,128,256,512,1024] Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order. Constraints: 1 $\\leq$ arr.length $\\leq$ 500 0 $\\leq$ arr[i] $\\leq$ 104 ","date":"2022-03-07","objectID":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/:1:0","tags":["array","bit manipulation","sorting","counting","easy","c++"],"title":"LeetCode 1356. Sort Integers by The Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/"},{"categories":["leetcode"],"content":"想法 首先，Count the number of 1 Bits 在前面已經實作過了，只是這一次題目沒有要求實際手刻計算方法，那就從善如流地使用 __builtin_popcount 這個 function 吧！ 接下來要討論如何進行 bits 數分類，若有許多數字有相同的 1 bits 再次進行數字排序。 ","date":"2022-03-07","objectID":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/:2:0","tags":["array","bit manipulation","sorting","counting","easy","c++"],"title":"LeetCode 1356. Sort Integers by The Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/"},{"categories":["leetcode"],"content":"解法 ","date":"2022-03-07","objectID":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/:3:0","tags":["array","bit manipulation","sorting","counting","easy","c++"],"title":"LeetCode 1356. Sort Integers by The Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/"},{"categories":["leetcode"],"content":"解法一 這是非常典型的 bucket sort，在 [Top K Frequent Elements] 這題曾經寫過變形題：先開一個二維 vector ，每個 row 當作 1 個 bucket，因為最多的情況是有 31 bits，共有 32 種可能性，所以我們總共需要 32 個 buckets。 從 arr 中一一讀取出來，依照 1 bits 數放到對應的 row/bucket 中。 這樣 bucket sort 就完成了，只要從第一個 row 開始一一查訪，就能得到依照 1 bits 數量排序的數列。 但是題目還有要求要每個 bucket 內部也要依照數字由小排到大呀！ 所以在輸出之前，只好先將每個 bucket 內部排序一下。 // 191. Number of 1 Bits int countBits(int n) { auto count = 0; while(n) { n \u0026= (n-1); count++; } return count; } vector\u003cint\u003e sortByBits(vector\u003cint\u003e\u0026 arr) { // 已經知道最多就 31 個 bits vector\u003cvector\u003cint\u003e\u003e bucket(32); // 先將所有的數字依據 1 bit 的數量放進對應的 bucket 中 for(auto i:arr) { bucket[countBits(i)].push_back(i); } // 待會要將數字一一輸出到這裡 vector\u003cint\u003e ans; // 從 1 bit 數量為 0 的 bucket 開始輸出 for(auto i=0; i\u003cbucket.size(); i++) { // 若有多個數字有相同的 1 bit 數量，則須依照數字順序輸出 sort(bucket[i].begin(), bucket[i].end()); // 輸出相同 1 bit 數量的 bucket 成員們 for(auto j=0; j\u003cbucket[i].size(); j++) { ans.push_back(bucket[i][j]); } } return ans; } Time complexity: $\\mathcal{O}(n)$. (其中 worst case 是 $\\mathcal{O}(nlog(n))$.) Space complexity: $\\mathcal{O}(n)$. ","date":"2022-03-07","objectID":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/:3:1","tags":["array","bit manipulation","sorting","counting","easy","c++"],"title":"LeetCode 1356. Sort Integers by The Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/"},{"categories":["leetcode"],"content":"解法二 孤陋寡聞，這 sort 方法還真是第一次用……。 先舉個例子： class Aclass { public: ... bool operator\u003c(Aclass const\u0026 other) { ... } }; int main() { Foo a, b; a \u003c b; } 前面這個執行的是 a.operator\u003c(b) 後面這個執行的是 operator\u003c(a, b)，後面經過 overload 後這個不須要引入 member。 class Aclass { ... }; bool operator\u003c(Aclass const\u0026 c1, Aclass const\u0026 c2) { ... } int main() { Aclass a, b; a \u003c b; } 應該稍微可以感受的到差異了吧 static bool compare(const int \u0026a, const int \u0026b) { int c1 = __builtin_popcount(a); int c2 = __builtin_popcount(b); // 當 bits 總數相同時，內部排序 if(c1 == c2) { return a \u003c b; } // 排法為由小至大 return c1 \u003c c2; } vector\u003cint\u003e sortByBits(vector\u003cint\u003e\u0026 arr) { sort(arr.begin(), arr.end(), compare); return arr; } Time complexity: $\\mathcal{O}(nlog(n))$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-03-07","objectID":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/:3:2","tags":["array","bit manipulation","sorting","counting","easy","c++"],"title":"LeetCode 1356. Sort Integers by The Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/"},{"categories":["leetcode"],"content":"Reference https://www.geeksforgeeks.org/builtin-functions-gcc-compiler/ https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/discuss/534631/C%2B%2B-beats-100-with-__builtin_popcount https://stackoverflow.com/questions/26131112/why-stdsort-requires-static-compare-function ","date":"2022-03-07","objectID":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/:4:0","tags":["array","bit manipulation","sorting","counting","easy","c++"],"title":"LeetCode 1356. Sort Integers by The Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_1356_sort_integers_by_the_number_of_1_bits/"},{"categories":["leetcode"],"content":"題目 Problem Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range $[0, 10^4]$. $-10^5 \\leq$ Node.val $\\leq 10^5$ pos is -1 or a valid index in the linked-list. Follow up: Can you solve it using $\\mathcal{O}(1)$ (i.e. constant) memory? ","date":"2022-02-28","objectID":"/posts/leetcode/leetcode_141_linked_list_cycle/:1:0","tags":["hash table","linked list","two pointers","easy","c++"],"title":"LeetCode 141. Linked List Cycle 解題紀錄","uri":"/posts/leetcode/leetcode_141_linked_list_cycle/"},{"categories":["leetcode"],"content":"想法 這題我看了 n 遍才看懂他在幹嘛 orz 新增兩個指標，分別叫做 walk 和 run ，每一秒走一個、跑兩格。 前三個點為單向通行，不在 cycle 裡面，後五個點屬於 cycle 之中。 如果這個 linked list 存在 cycle，則 walk 和 run 總有一秒會相遇。 下圖中可以看到： 第零秒兩個同時從 1 出發，到第五秒時兩個在 6 相遇。 walk and run in the linked list ","date":"2022-02-28","objectID":"/posts/leetcode/leetcode_141_linked_list_cycle/:2:0","tags":["hash table","linked list","two pointers","easy","c++"],"title":"LeetCode 141. Linked List Cycle 解題紀錄","uri":"/posts/leetcode/leetcode_141_linked_list_cycle/"},{"categories":["leetcode"],"content":"相遇時間 至於要花幾秒才會相遇呢? 先耗費走完 line 的時間 當 walk 進入 cycle 中後，再來只要看 cycle line % cycle 是在等待 walk 進入 cycle 時，run 的位置 run 應花費 cycle - (line % cycle) 的時間追上 walk 設 $line = 3$ 和 $cycle = 5$ $ line+(cycle-(line\\mod cycle))$ $= 3 + (5-(3 \\mod 5)) $ $= 3+(5-3) $ $= 3+2 = 5 $ ⇒ 總共需要 $5 秒/steps$ pos 就是這樣反推出來ㄉ 凸^-^凸 ","date":"2022-02-28","objectID":"/posts/leetcode/leetcode_141_linked_list_cycle/:2:1","tags":["hash table","linked list","two pointers","easy","c++"],"title":"LeetCode 141. Linked List Cycle 解題紀錄","uri":"/posts/leetcode/leetcode_141_linked_list_cycle/"},{"categories":["leetcode"],"content":"解法 bool hasCycle(ListNode *head) { if(!head) return head; // walk 和 slow 都從起點出發 ListNode *walk = head, *run = head; while(run-\u003enext \u0026\u0026 run-\u003enext-\u003enext) { // 一次走一步 walk = walk-\u003enext; // 一次走兩步 run = run-\u003enext-\u003enext; // walk 和 run 會重疊代表著 linked list 中有迴圈 if(walk == run) { return 1; } } return 0; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-02-28","objectID":"/posts/leetcode/leetcode_141_linked_list_cycle/:3:0","tags":["hash table","linked list","two pointers","easy","c++"],"title":"LeetCode 141. Linked List Cycle 解題紀錄","uri":"/posts/leetcode/leetcode_141_linked_list_cycle/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints: 1 $\\leq$ nums.length $\\leq 10^5$ $-10^9 \\leq$ nums[i] $\\leq 10^9$ ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:1:0","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"想法 作法大致分為先排序及未排序兩種：排序後檢查是否有出現接連兩個相同數字，另一種則是開新的儲存空間一一記錄是否曾出現過。 ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:2:0","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"解法 ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:3:0","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"解法一：unordered_set 遍歷 nums 中所有元素，並儲存至 mp 中。 若 mp 的 size 和 nums 的 size 不同，表示有出現重複的元素。 bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { unordered_set\u003cint\u003e mp; for(auto i:nums) { mp.insert(i); } if(nums.size() != mp.size()) { return 1; } return 0; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:3:1","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"解法二：unordered_map 遍歷 nums 中所有元素，以 unordered_map 紀錄是否曾出現過。 bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { unordered_map\u003cint, bool\u003e mp; for(auto i:nums) { /* 若 mp[i] 的值已經註記為出現過 */ if(mp[i] == 1) { return 1; } /* 將 mp[i] 註記為出現過 */ mp[i] = 1; } return 0; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:3:2","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"解法三：sort 將 nums 中元素排序，排序後檢查是否有相鄰的數字相等，若有相等的數字，即為出現重複的元素。 bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { sort(nums.begin(), nums.end()); /* 檢查相鄰的數字是否相等 */ for(auto i=0; i\u003cnums.size()-1; i++) { if(nums[i] == nums[i+1]) { return 1; } } return 0; } C++ 中 sort 的時間複雜度為 $\\mathcal{O}(n log(n))$，加上一一檢查相鄰元素的時間 $\\mathcal{O}(n)$ ==\u003e $\\mathcal{O}(n)$. Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:3:3","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"解法四：bitset 我們只是要檢驗其數字在數字空間中是否重疊，所以可以將所有數字化為正值： 先建立一個能裝下從負值到正值大小的 bitmap，再來是檢查是否已經在 bitmap 中存在，若有則返回 1，無則放進 bitmap。 bool containsDuplicate(vector\u003cint\u003e\u0026 nums) { bitset\u003c2000000\u003e bset; for(auto i:nums) { i += 1000000; if(bset.test(i)) { return 1; break; } bset.set(i); } return 0; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:3:4","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"各方法比較 記得曾經看過有人說，LeetCode 的時間跟你當下的網路順暢有關 😢 方法 時間 記憶體 Unordered set 90 ms 20.2 MB Sort 54 ms 15.6 MB Bitmap 27 ms 15.8 MB ","date":"2022-02-21","objectID":"/posts/leetcode/leetcode_217_contains_duplicate/:3:5","tags":["array","hash table","sorting","easy","c++"],"title":"LeetCode 217. Contains Duplicate 解題紀錄","uri":"/posts/leetcode/leetcode_217_contains_duplicate/"},{"categories":["leetcode"],"content":"題目 Problem Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2: Input: head = [] Output: [] Example 3: Input: head = [1] Output: [1] Constraints: The number of nodes in the list is in the range [0, 100]. 0 $\\leq$ Node.val $\\leq$ 100 ","date":"2022-02-14","objectID":"/posts/leetcode/leetcode_24_swap_nodes_in_pairs/:1:0","tags":["linked list","recursion","medium","c++"],"title":"LeetCode 24. Swap Nodes in Pairs 解題紀錄","uri":"/posts/leetcode/leetcode_24_swap_nodes_in_pairs/"},{"categories":["leetcode"],"content":"想法 下列所有圖片中的 nodes 皆已按照 linked 順序排列，虛線部分為規畫路徑。 移動前，規劃路徑如下： 由於第一個 node 會改變，因此我們先新增一個起始點 pre，它的用途在於指向第一個 node。 要移動 node-\u003enext 需要往後一直進行 recursion，因此我們又新增一個指標 cur 指向 pre。 每次 recursion 只要交換一組相鄰的點，第一次我們要交換的是 1 和 2。 第一步 移動後，再進入下一步： 下一步 ","date":"2022-02-14","objectID":"/posts/leetcode/leetcode_24_swap_nodes_in_pairs/:2:0","tags":["linked list","recursion","medium","c++"],"title":"LeetCode 24. Swap Nodes in Pairs 解題紀錄","uri":"/posts/leetcode/leetcode_24_swap_nodes_in_pairs/"},{"categories":["leetcode"],"content":"解法 ListNode* swapPairs(ListNode* head) { if(!head) return head; /* 新增一個點 pre 指向 head*/ ListNode pre(0); pre.next = head; ListNode *cur = \u0026pre; while(cur-\u003enext \u0026\u0026 cur-\u003enext-\u003enext) { /* 暫存兩個點的資料，方便進行移動 */ ListNode *tmp1 = cur-\u003enext; ListNode *tmp2 = cur-\u003enext-\u003enext-\u003enext; cur-\u003enext = cur-\u003enext-\u003enext; // * -\u003e 2 cur-\u003enext-\u003enext = tmp1; // 2 -\u003e 1 cur-\u003enext-\u003enext-\u003enext = tmp2; // 1 -\u003e 3 cur = cur-\u003enext-\u003enext; } return pre.next; } 其中，新增點 pre 的方法也可以這樣寫： 上面的做法是直接新增點 pre，並使用 cur 指向它； 下面的作法是先新增指標 pre 指向新的點，再另外使用 cur 指向它。 ListNode *pre = new ListNode(0); pre-\u003enext = head; ListNode *cur = pre; ... return pre-\u003enext; Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-02-14","objectID":"/posts/leetcode/leetcode_24_swap_nodes_in_pairs/:3:0","tags":["linked list","recursion","medium","c++"],"title":"LeetCode 24. Swap Nodes in Pairs 解題紀錄","uri":"/posts/leetcode/leetcode_24_swap_nodes_in_pairs/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: Input: nums = [1] Output: 1 Example 3: Input: nums = [5,4,-1,7,8] Output: 23 Constraints: 1 \u003c= nums.length \u003c= 105 $-10^4 \\leq$ nums[i] $\\leq 10^4$ Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. ","date":"2022-02-07","objectID":"/posts/leetcode/leetcode_53_maximum_subarray/:1:0","tags":["array","divide and conquer","dynamic programming","easy","c++"],"title":"LeetCode 53. Maximum Subarray 解題紀錄","uri":"/posts/leetcode/leetcode_53_maximum_subarray/"},{"categories":["leetcode"],"content":"解法 ","date":"2022-02-07","objectID":"/posts/leetcode/leetcode_53_maximum_subarray/:2:0","tags":["array","divide and conquer","dynamic programming","easy","c++"],"title":"LeetCode 53. Maximum Subarray 解題紀錄","uri":"/posts/leetcode/leetcode_53_maximum_subarray/"},{"categories":["leetcode"],"content":"解法一：暴力解 全部可能的 subarray 計算過一輪，就能得到總和最大的值。 先比較 nums 中自己和從頭到自己哪個較大，再比較 local maximum 中誰最大。 注意： 因為有可能 local maximum 都是負值，所以要將 maxi 設為 INT_MIN。 int maxSubArray(vector\u003cint\u003e\u0026 nums) { auto maxi = INT_MIN, sum = 0; for(auto i=0; i\u003cnums.size(); i++) { for(auto j=i, sum=0; j\u003cnums.size(); j++) { // 一直累加 sum += nums[j]; // 紀錄最大值 maxi = max(maxi, sum); } } return maxi; } Time complexity: $\\mathcal{O}(n^2)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-02-07","objectID":"/posts/leetcode/leetcode_53_maximum_subarray/:2:1","tags":["array","divide and conquer","dynamic programming","easy","c++"],"title":"LeetCode 53. Maximum Subarray 解題紀錄","uri":"/posts/leetcode/leetcode_53_maximum_subarray/"},{"categories":["leetcode"],"content":"解法二：DP 若從 $(a_1+ … + a_n+a_{n+1})$ 大於 $a_{n+1}$ 獨自起始，那麼我們可以認為團結繼續進行加法的值會越來越大；反之，若 $(a_1+ … + a_n+a_{n+1})$ 小於 $a_{n+1}$，由此從頭開始 / 斷尾累計反而比較好。 紀錄每次斷尾的最大值為多少。 dynamic programming 透過上圖： 由第二個元素 1 可知，與前面項的總和相比，它自己可以獨立產生一個更大的值，於是我們就選擇從它這個項目開始累加，放棄前面累計的值。 由第八個元素 -5 可知，前幾項累計最大值為 6，當將自己這項加上去，會使總和變小。 int maxSubArray(vector\u003cint\u003e\u0026 nums) { auto maxi = INT_MIN, sum = 0; for(auto i:nums) { // 斷尾 or 延續前面的 subarray sum = max(i, sum+i); // 紀錄最大值 maxi = max(sum, maxi); } return maxi; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. 太久沒寫 DP 題目、或是對敘述理解不來，可以嘗試看看自己寫一遍 😄 try dynamic programming yourself :) ","date":"2022-02-07","objectID":"/posts/leetcode/leetcode_53_maximum_subarray/:2:2","tags":["array","divide and conquer","dynamic programming","easy","c++"],"title":"LeetCode 53. Maximum Subarray 解題紀錄","uri":"/posts/leetcode/leetcode_53_maximum_subarray/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: Input: n = 27 Output: true Example 2: Input: n = 0 Output: false Example 3: Input: n = 9 Output: true Constraints: $-2^{31} \\leq n \\leq 2^{31} - 1$ Follow up: Could you solve it without loops/recursion? ","date":"2022-01-31","objectID":"/posts/leetcode/leetcode_326_power_of_three/:1:0","tags":["math","recursion","easy","c++"],"title":"LeetCode 326. Power of Three 解題紀錄","uri":"/posts/leetcode/leetcode_326_power_of_three/"},{"categories":["leetcode"],"content":"想法 最簡單的方法就是一直除以 3，若餘數也是 3 的倍數，且該數字 $n$ 已經除到 1 $(=3^0)$ 時，表示它是 3 的次方，反之則否。 ","date":"2022-01-31","objectID":"/posts/leetcode/leetcode_326_power_of_three/:2:0","tags":["math","recursion","easy","c++"],"title":"LeetCode 326. Power of Three 解題紀錄","uri":"/posts/leetcode/leetcode_326_power_of_three/"},{"categories":["leetcode"],"content":"解法 ","date":"2022-01-31","objectID":"/posts/leetcode/leetcode_326_power_of_three/:3:0","tags":["math","recursion","easy","c++"],"title":"LeetCode 326. Power of Three 解題紀錄","uri":"/posts/leetcode/leetcode_326_power_of_three/"},{"categories":["leetcode"],"content":"解法一 就是一直除以 3。 bool isPowerOfThree(int n) { if(n\u003c1) return 0; while(n%3 == 0) { n/=3; } return n==1; } Time complexity: $\\mathcal{O}(log_3(n))$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-01-31","objectID":"/posts/leetcode/leetcode_326_power_of_three/:3:1","tags":["math","recursion","easy","c++"],"title":"LeetCode 326. Power of Three 解題紀錄","uri":"/posts/leetcode/leetcode_326_power_of_three/"},{"categories":["leetcode"],"content":"解法二 題目要求不能做任何的 loop，這題最好想個 15 分鐘。 提示：要用到 $log$ 不 😢 要 😢 偷 😢 看 😢 啦 😢 沒關係，我也忘光光了，附上小抄： Laws of Logarithms $log_{a} x + log_{a} y = log_{a}(x \\times y)$ $log_{b} x - log_{b} y = \\frac{log_{b} x}{log_{b} y} = log_{y} x$ $log_{a^m} x^n = \\frac{n}{m} log_{a} x$ $log_{a}(1) = 0$ $log_{a}(a) = 1$ $log_{a}(a^n) = n$ 假設 $n = 81 = 3^4$，$n$ 已知是 $3$ 的次方， 根據小抄第六點，$log_3 81 = log_3 {3^4} = 4$，只要以 3 為底取 $log$，檢查是否為整數就好。 事情沒那麼簡單，C++ 沒有以 3 為底的 $log$，我們必須用小抄第三點進行換底： $log_3 81 = \\frac{log_{10} 81}{log_{10} 3}$ 再根據小抄第二點： $\\frac{log_{10} 81}{log_{10} 3} = log_{10} 81 - log_{10} 3$ 最後，我們推得 只要 $log_{10} n - log_{10} 3$ 結果是整數，表示 $n$ 是 3 的次方。 bool isPowerOfThree(int n) { if(n\u003c1) return 0; auto ans = log10(n)/log10(3); return int(ans) == ans; } Time complexity: $\\mathcal{O}(1)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-01-31","objectID":"/posts/leetcode/leetcode_326_power_of_three/:3:2","tags":["math","recursion","easy","c++"],"title":"LeetCode 326. Power of Three 解題紀錄","uri":"/posts/leetcode/leetcode_326_power_of_three/"},{"categories":["leetcode"],"content":"Reference ","date":"2022-01-31","objectID":"/posts/leetcode/leetcode_326_power_of_three/:4:0","tags":["math","recursion","easy","c++"],"title":"LeetCode 326. Power of Three 解題紀錄","uri":"/posts/leetcode/leetcode_326_power_of_three/"},{"categories":["leetcode"],"content":"題目 Problem Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. Constraints: 1 $\\leq$ nums1.length, nums2.length $\\leq$ 1000 0 $\\leq$ nums1[i], nums2[i] $\\leq$ 1000 Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1’s size is small compared to nums2’s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? ","date":"2022-01-24","objectID":"/posts/leetcode/leetcode_350_intersection_of_two_arrays_ii/:1:0","tags":["array","hash table","two pointers","binary search","sorting","easy","c++"],"title":"LeetCode 350. Intersection of Two Arrays II 解題紀錄","uri":"/posts/leetcode/leetcode_350_intersection_of_two_arrays_ii/"},{"categories":["leetcode"],"content":"想法 確認兩個 array 中是否有 size 為 0 的情況，若有，則直接 return 空。 遍歷 array 中所有個數，紀錄到 unordered_map 中 另一個 array 則檢查是否對應的 key 值不為 0，表示前一個 array 中也有這個元素，故印出它。 ","date":"2022-01-24","objectID":"/posts/leetcode/leetcode_350_intersection_of_two_arrays_ii/:2:0","tags":["array","hash table","two pointers","binary search","sorting","easy","c++"],"title":"LeetCode 350. Intersection of Two Arrays II 解題紀錄","uri":"/posts/leetcode/leetcode_350_intersection_of_two_arrays_ii/"},{"categories":["leetcode"],"content":"解法 vector\u003cint\u003e intersect(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) { // 檢查是否有 array 為空，若為空，則不可能有交集 if(!nums1.size() || !nums2.size()) return {}; vector\u003cint\u003e ans; // 紀錄每個數字出現的次數 unordered_map\u003cint, int\u003e mp; for(auto i:nums1) { mp[i]++; } for(auto i:nums2) { // 若 mp[i] != 0 表示有交集 if(mp[i]) { ans.push_back(i); mp[i]--; } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2022-01-24","objectID":"/posts/leetcode/leetcode_350_intersection_of_two_arrays_ii/:3:0","tags":["array","hash table","two pointers","binary search","sorting","easy","c++"],"title":"LeetCode 350. Intersection of Two Arrays II 解題紀錄","uri":"/posts/leetcode/leetcode_350_intersection_of_two_arrays_ii/"},{"categories":["leetcode"],"content":"題目 Problem You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location. Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1. The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2). Example 1: Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]] Output: 2 Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2. Example 2: Input: x = 3, y = 4, points = [[3,4]] Output: 0 Explanation: The answer is allowed to be on the same location as your current location. Example 3: Input: x = 3, y = 4, points = [[2,3]] Output: -1 Explanation: There are no valid points. Constraints: 1 $\\leq$ points.length $\\leq 10^4$ points[i].length == 2 1 $\\leq x , y, a_i, b_i \\leq 10^4$ ","date":"2022-01-17","objectID":"/posts/leetcode/leetcode_1779_find_nearest_point_that_has_the_same_x_or_y_coordinate/:1:0","tags":["array","easy","c++"],"title":"LeetCode 1779. Find Nearest Point That Has the Same X or Y Coordinate 解題紀錄","uri":"/posts/leetcode/leetcode_1779_find_nearest_point_that_has_the_same_x_or_y_coordinate/"},{"categories":["leetcode"],"content":"想法 確認是否和指定座標有相同的 $x$ 座標 或是 $y$ 座標 取得和指定座標 $(x, y)$ 的距離，計算方式為：$\\lvert(x_1 - x_2)\\rvert + \\lvert(y_1 - y_2)\\rvert$ 求所有距離中的最小值 ","date":"2022-01-17","objectID":"/posts/leetcode/leetcode_1779_find_nearest_point_that_has_the_same_x_or_y_coordinate/:2:0","tags":["array","easy","c++"],"title":"LeetCode 1779. Find Nearest Point That Has the Same X or Y Coordinate 解題紀錄","uri":"/posts/leetcode/leetcode_1779_find_nearest_point_that_has_the_same_x_or_y_coordinate/"},{"categories":["leetcode"],"content":"解法 int nearestValidPoint(int x, int y, vector\u003cvector\u003cint\u003e\u003e\u0026 points) { // minipos 紀錄第幾組為最小距離，mini 計算最小距離的值 auto minpos = -1, mini = INT_MAX; // 遍歷所有座標 for(auto i=0; i\u003cpoints.size(); i++) { // 確認這個座標是否符合條件 if(points[i][0]==x || points[i][1]==y) { // 根據公式計算距離 auto dis = abs(x-points[i][0]) + abs(y-points[i][1]); // 有更接近的座標距離出現 if(mini \u003e dis) { minpos = i; mini = dis; } } } return minpos; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-01-17","objectID":"/posts/leetcode/leetcode_1779_find_nearest_point_that_has_the_same_x_or_y_coordinate/:3:0","tags":["array","easy","c++"],"title":"LeetCode 1779. Find Nearest Point That Has the Same X or Y Coordinate 解題紀錄","uri":"/posts/leetcode/leetcode_1779_find_nearest_point_that_has_the_same_x_or_y_coordinate/"},{"categories":["leetcode"],"content":"題目 Problem You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: nums1.length == m + n nums2.length == n 0 $\\leq$ m, n $\\leq$ 200 1 $\\leq$ m + n $\\leq$ 200 $-10^9 \\leq$ nums1[i], nums2[j] $\\leq 10^9$ Follow up: Can you come up with an algorithm that runs in $\\mathcal{O}(m+n)$ time? ","date":"2022-01-10","objectID":"/posts/leetcode/leetcode_88_merge_sorted_array/:1:0","tags":["array","two pointers","sorting","easy","c++"],"title":"LeetCode 88. Merge Sorted Array 解題紀錄","uri":"/posts/leetcode/leetcode_88_merge_sorted_array/"},{"categories":["leetcode"],"content":"想法 要把所有的值依照 sorted 塞回 nums1 裡，只要比較兩個 array 中最大值就可以知道應該要把誰放進去了。 如果 nums1 全部的值都比 nums2 大，則需要最後一個 while 將所有值放進 nums1。 ","date":"2022-01-10","objectID":"/posts/leetcode/leetcode_88_merge_sorted_array/:2:0","tags":["array","two pointers","sorting","easy","c++"],"title":"LeetCode 88. Merge Sorted Array 解題紀錄","uri":"/posts/leetcode/leetcode_88_merge_sorted_array/"},{"categories":["leetcode"],"content":"解法 void merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) { auto i = m-1, j = n-1, pos = m+n-1; while(i\u003e=0 \u0026\u0026 j\u003e=0) { if(nums1[i] \u003c nums2[j]) { nums1[pos--] = nums2[j--]; } else { nums1[pos--] = nums1[i--]; } } while(j\u003e=0) { nums1[pos--] = nums2[j--]; } } Time complexity: $\\mathcal{O}(m+n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2022-01-10","objectID":"/posts/leetcode/leetcode_88_merge_sorted_array/:3:0","tags":["array","two pointers","sorting","easy","c++"],"title":"LeetCode 88. Merge Sorted Array 解題紀錄","uri":"/posts/leetcode/leetcode_88_merge_sorted_array/"},{"categories":["leetcode"],"content":"題目 Problem Given two binary strings a and b, return their sum as a binary string. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" Constraints: 1 $\\leq$ a.length, b.length $\\leq$ $10^4$ a and b consist only of ‘0’ or ‘1’ characters. Each string does not contain leading zeros except for the zero itself. ","date":"2022-01-03","objectID":"/posts/leetcode/leetcode_67_add_binary/:1:0","tags":["math","string","bit manipulation","simulation","easy","c++"],"title":"LeetCode 67. Add Binary 解題紀錄","uri":"/posts/leetcode/leetcode_67_add_binary/"},{"categories":["leetcode"],"content":"想法 由 a 和 b 兩字串的尾端讀取，假如該位置合法 (\u003e=0)，則確認是否有較小位值的進位 (holder)，再依據二進位的進位法則進行計算。 看這邊或是下面的小抄 string to int: a[i] - '0' int to string: to_string(intA) ps: 這個問題好像被我 google 了 n 遍了 🤣 ","date":"2022-01-03","objectID":"/posts/leetcode/leetcode_67_add_binary/:2:0","tags":["math","string","bit manipulation","simulation","easy","c++"],"title":"LeetCode 67. Add Binary 解題紀錄","uri":"/posts/leetcode/leetcode_67_add_binary/"},{"categories":["leetcode"],"content":"解法 string addBinary(string a, string b) { string ans = \"\"; // 由最右邊/最小的位置開始計算 int i=a.size()-1, j=b.size()-1, holder=0; while(i\u003e=0 || j\u003e=0 || holder\u003e0) { if(i\u003e=0) { holder += (a[i]-'0'); i--; } if(j\u003e=0) { holder += (b[j]-'0'); j--; } // 檢查是否有進位後剩下的數值 ans = to_string(holder%2) + ans; // 已經進位 holder /= 2; } return ans; } ","date":"2022-01-03","objectID":"/posts/leetcode/leetcode_67_add_binary/:3:0","tags":["math","string","bit manipulation","simulation","easy","c++"],"title":"LeetCode 67. Add Binary 解題紀錄","uri":"/posts/leetcode/leetcode_67_add_binary/"},{"categories":["leetcode"],"content":"縮寫 string addBinary(string a, string b) { string ans = \"\"; // 由最右邊/最小的位置開始計算 int i=a.size()-1, j=b.size()-1, holder=0; while(i\u003e=0 || j\u003e=0 || holder\u003e0) { holder += i\u003e=0 ? (a[i--]-'0') : 0; holder += j\u003e=0 ? (b[j--]-'0') : 0; // 檢查是否有進位後剩下的數值 ans = to_string(holder\u00261) + ans; // 已經進位 holder \u003e\u003e= 1; } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. 下面這種縮寫寫法並不會快到多少，面試時用一下炫技可以，平時寫專案我不大敢用，以我的看 code 速度，n /= 2 絕對比 n \u003e\u003e= 1 容易懂。 個人其實還蠻喜歡這題考的型別轉換加上 edge case 思考。 ","date":"2022-01-03","objectID":"/posts/leetcode/leetcode_67_add_binary/:3:1","tags":["math","string","bit manipulation","simulation","easy","c++"],"title":"LeetCode 67. Add Binary 解題紀錄","uri":"/posts/leetcode/leetcode_67_add_binary/"},{"categories":["leetcode"],"content":"Reference https://stackoverflow.com/questions/11310898/how-do-i-get-the-type-of-a-variable ","date":"2022-01-03","objectID":"/posts/leetcode/leetcode_67_add_binary/:4:0","tags":["math","string","bit manipulation","simulation","easy","c++"],"title":"LeetCode 67. Add Binary 解題紀錄","uri":"/posts/leetcode/leetcode_67_add_binary/"},{"categories":["leetcode"],"content":"題目 Problem You are given an array prices where prices[i] is the price of a given stock on the $i^{th}$ day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 $\\leq$ prices.length $\\leq 10^5$ 0 $\\leq$ prices[i] $\\leq 10^4$ ","date":"2021-12-27","objectID":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/:1:0","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 121. Best Time to Buy and Sell Stock 解題紀錄","uri":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/"},{"categories":["leetcode"],"content":"想法 Info try dynamic programming yourself :) ","date":"2021-12-27","objectID":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/:2:0","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 121. Best Time to Buy and Sell Stock 解題紀錄","uri":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/"},{"categories":["leetcode"],"content":"解法 ","date":"2021-12-27","objectID":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/:3:0","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 121. Best Time to Buy and Sell Stock 解題紀錄","uri":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/"},{"categories":["leetcode"],"content":"解法一 int maxProfit(vector\u003cint\u003e\u0026 prices) { if(prices.size()\u003c2) return 0; auto buy = INT_MAX, profit = 0; for(auto i:prices) { buy = min(i, buy); profit = max(profit, i-buy); } return profit; } ","date":"2021-12-27","objectID":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/:3:1","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 121. Best Time to Buy and Sell Stock 解題紀錄","uri":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/"},{"categories":["leetcode"],"content":"解法二 int maxProfit(vector\u003cint\u003e\u0026 prices) { int profit = 0, buy = prices[0]; if(prices.size() \u003c 2) return 0; for(auto i=1; i\u003cprices.size(); ++i) { if(prices[i] \u003e prices[i-1]) { profit = max(profit, prices[i] - buy); } else { buy = min(buy, prices[i]); } } return profit; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2021-12-27","objectID":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/:3:2","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 121. Best Time to Buy and Sell Stock 解題紀錄","uri":"/posts/leetcode/leetcode_121_best_time_to_buy_and_sell_stock/"},{"categories":["leetcode"],"content":"題目 Problem There is a function signFunc(x) that returns: 1 if x is positive. -1 if x is negative. 0 if x is equal to 0. You are given an integer array nums. Let product be the product of all values in the array nums. Return signFunc(product). Example 1: Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 Example 2: Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 Example 3: Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 Constraints: 1 $\\leq$ nums.length $\\leq$ 1000 -100 $\\leq$ nums[i] $\\leq$ 100 ","date":"2021-12-20","objectID":"/posts/leetcode/leetcode_1822_sign_of_the_product_of_an_array/:1:0","tags":["array","math","easy","c++"],"title":"LeetCode 1822. Sign of the Product of an Array 解題紀錄","uri":"/posts/leetcode/leetcode_1822_sign_of_the_product_of_an_array/"},{"categories":["leetcode"],"content":"想法 當 nums 中有任何元素為 0，乘積必為 0；會造成結果 +1 與 -1 擺盪，只與數字前的正負號有關，所以可以忽略數值的運算。 ","date":"2021-12-20","objectID":"/posts/leetcode/leetcode_1822_sign_of_the_product_of_an_array/:2:0","tags":["array","math","easy","c++"],"title":"LeetCode 1822. Sign of the Product of an Array 解題紀錄","uri":"/posts/leetcode/leetcode_1822_sign_of_the_product_of_an_array/"},{"categories":["leetcode"],"content":"解法 int arraySign(vector\u003cint\u003e\u0026 nums) { auto ans = 1; for(auto i:nums) { // 只有 nums 中有元素為 0，乘積必為 0 if(i == 0) return 0; // 若這個元素為負值，必定會造成結果乘以 (-1) if(i\u003c0) { ans = (-1) * ans; } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-12-20","objectID":"/posts/leetcode/leetcode_1822_sign_of_the_product_of_an_array/:3:0","tags":["array","math","easy","c++"],"title":"LeetCode 1822. Sign of the Product of an Array 解題紀錄","uri":"/posts/leetcode/leetcode_1822_sign_of_the_product_of_an_array/"},{"categories":["leetcode"],"content":"題目 Problem In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: Input: mat = [[1,2],[3,4]], r = 1, c = 4 Output: [[1,2,3,4]] Example 2: Input: mat = [[1,2],[3,4]], r = 2, c = 4 Output: [[1,2],[3,4]] Constraints: m == mat.length n == mat[i].length 1 $\\leq$ m, n $\\leq$ 100 -1000 $\\leq$ mat[i][j] $\\leq$ 1000 1 $\\leq$ r, c $\\leq$ 300 ","date":"2021-12-13","objectID":"/posts/leetcode/leetcode_566_reshape_the_matrix/:1:0","tags":["array","matrix","simulation","easy","c++"],"title":"LeetCode 566. Reshape the Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_566_reshape_the_matrix/"},{"categories":["leetcode"],"content":"想法 把原本的元素依序存入暫存的一維陣列中，再依照指定修正後的 matrix 大小一一存入。 ","date":"2021-12-13","objectID":"/posts/leetcode/leetcode_566_reshape_the_matrix/:2:0","tags":["array","matrix","simulation","easy","c++"],"title":"LeetCode 566. Reshape the Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_566_reshape_the_matrix/"},{"categories":["leetcode"],"content":"解法 vector\u003cvector\u003cint\u003e\u003e matrixReshape(vector\u003cvector\u003cint\u003e\u003e\u0026 mat, int r, int c) { // 指定修正大小不符合規定則回傳原始 mat if(!mat.size() || !mat[0].size()) return mat; if(mat.size() * mat[0].size() != r*c) return mat; // 設定修改後的 mat vector\u003cvector\u003cint\u003e\u003e ans(r, vector\u003cint\u003e (c, 0)); // 將所有元素存入一個一維 temp array 中 vector\u003cint\u003e temp(r*c, 0); for(auto i=0, t=0; i\u003cmat.size(); i++) { for(auto j=0; j\u003cmat[0].size(); j++) { temp[t++] = mat[i][j]; } } // 存入修改後的 mat for(auto i=0, t=0; i\u003cr; i++) { for(auto j=0; j\u003cc; j++) { ans[i][j] = temp[t++]; } } return ans; } Time complexity: $\\mathcal{O}(n^2)$. Space complexity: $\\mathcal{O}(n^2)$. ","date":"2021-12-13","objectID":"/posts/leetcode/leetcode_566_reshape_the_matrix/:3:0","tags":["array","matrix","simulation","easy","c++"],"title":"LeetCode 566. Reshape the Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_566_reshape_the_matrix/"},{"categories":["leetcode"],"content":"題目 Problem Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false Constraints: m == matrix.length n == matrix[i].length 1 $\\leq$ m, n $\\leq$ 100 $-10^4 \\leq$ matrix[i][j], target $\\leq$ 104 ","date":"2021-12-06","objectID":"/posts/leetcode/leetcode_74_search_a_2d_matrix/:1:0","tags":["array","binary search","matrix","medium","c++"],"title":"LeetCode 74. Search a 2D Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_74_search_a_2d_matrix/"},{"categories":["leetcode"],"content":"想法 分兩種做法： 每一 row 都是已經依照順序排好的 vector，先依照每個 row 的第一個元素尋找，再往 column 內部檢查 將整個矩陣視為一個很長的已排序數列，使用 Two pointers 夾擊出元素。 Two pointers 若是出現一個已經排序好很長的 array，要搜尋某一數字，一個一個檢查太浪費時間了。 我們會直接抓正中間的元素和目標值比大小，若目標值比較大，則向右邊尋找； 若目標值比較小，則向左尋找，依照這個模式，可以有一個簡單的模板。 // 目標值 int target = 90; // 要搜尋的 array vector\u003cint\u003e arr = {1, 3, 5, 7, ... , 101}; auto left = 0, right = arr.size()-1; while(left \u003c= right) { // 取中間位置 int mid = (right + left) / 2; // 目標值較大 if(arr[mid] \u003c target) { left = mid + 1; } // 目標較小 else if(arr[mid] \u003e target) { right = mid - 1; } // 是目標 else { return 1; } return 0; } ","date":"2021-12-06","objectID":"/posts/leetcode/leetcode_74_search_a_2d_matrix/:2:0","tags":["array","binary search","matrix","medium","c++"],"title":"LeetCode 74. Search a 2D Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_74_search_a_2d_matrix/"},{"categories":["leetcode"],"content":"解法 ","date":"2021-12-06","objectID":"/posts/leetcode/leetcode_74_search_a_2d_matrix/:3:0","tags":["array","binary search","matrix","medium","c++"],"title":"LeetCode 74. Search a 2D Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_74_search_a_2d_matrix/"},{"categories":["leetcode"],"content":"解法一 bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { auto r = matrix.size(), c = matrix[0].size(); for(auto i=0; i\u003cr; i++) { // 比較前一行的最後一個元素與 target 的大小 if(matrix[i][c-1]\u003e=target) { for(auto j=0; j\u003cmatrix[i].size(); j++) { if(matrix[i][j] == target) { return 1; } } return 0; } } return 0; } Time complexity: $\\mathcal{O}(log(mn)) = {O}(log(m) + log(n))$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-12-06","objectID":"/posts/leetcode/leetcode_74_search_a_2d_matrix/:3:1","tags":["array","binary search","matrix","medium","c++"],"title":"LeetCode 74. Search a 2D Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_74_search_a_2d_matrix/"},{"categories":["leetcode"],"content":"解法二 bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int c = matrix[0].size(), r = matrix.size(), left = 0, right = r * c - 1; while(left \u003c= right) { // 取得中間的位置 int mid = (right + left) / 2; // 找到了 if(target == matrix[mid/c][mid%c]) { return 1; } // 往左邊尋找 else if(target \u003e matrix[mid/c][mid%c]) { left = mid + 1; } // 往右邊尋找 else { right = mid - 1; } } return 0; } Time complexity: $\\mathcal{O}(log(mn)) = {O}(log(m) + log(n))$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-12-06","objectID":"/posts/leetcode/leetcode_74_search_a_2d_matrix/:3:2","tags":["array","binary search","matrix","medium","c++"],"title":"LeetCode 74. Search a 2D Matrix 解題紀錄","uri":"/posts/leetcode/leetcode_74_search_a_2d_matrix/"},{"categories":["leetcode"],"content":"題目 Problem Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. Example 1: Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three ‘1’ bits. Example 2: Input: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one ‘1’ bit. Example 3: Input: n = 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one ‘1’ bits. Constraints: The input must be a binary string of length 32. Follow up: If this function is called many times, how would you optimize it? ","date":"2021-11-01","objectID":"/posts/leetcode/leetcode_191_number_of_1_bits/:1:0","tags":["bit manipulation","easy","c++"],"title":"LeetCode 191. Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_191_number_of_1_bits/"},{"categories":["leetcode"],"content":"想法 visualization of number of 1s 利用邏輯 and 的性質，從最末端一一扣除 1。 ","date":"2021-11-01","objectID":"/posts/leetcode/leetcode_191_number_of_1_bits/:2:0","tags":["bit manipulation","easy","c++"],"title":"LeetCode 191. Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_191_number_of_1_bits/"},{"categories":["leetcode"],"content":"解法 int hammingWeight(uint32_t n) { auto count = 0; while(n\u003e0) { n \u0026= n-1; count++; } return count; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-11-01","objectID":"/posts/leetcode/leetcode_191_number_of_1_bits/:3:0","tags":["bit manipulation","easy","c++"],"title":"LeetCode 191. Number of 1 Bits 解題紀錄","uri":"/posts/leetcode/leetcode_191_number_of_1_bits/"},{"categories":["Computer System"],"content":"string to int 現在我們要字串 a 的第 i 個字元：a[i]，希望能直接進行數字計算，只要將它改為 a[i]-'0'，它就是一個數字了！ #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctypeinfo\u003e using namespace std; int main() { string num = \"1234\"; cout \u003c\u003c \"Type of num is: \" \u003c\u003c typeid(num).name() \u003c\u003c endl \u003c\u003c \"Type of num[0] is: \" \u003c\u003c typeid(num[0]).name() \u003c\u003c endl \u003c\u003c \"Type of num[0]-'0' is: \" \u003c\u003c typeid(num[0]-'0').name() \u003c\u003c endl \u003c\u003c } 輸出為： Type of num is: Ss -\u003e string Type of num[0] is: c -\u003e char Type of num[0]-'0' is: i -\u003e integer 轉換的邏輯約莫是： string ➡ char ➡ int num ➡ num[0] ➡ num[0]-'0' int to string 從 int 轉回 string 就沒有簡單了，下列範例中，我們已經知道 intNum 是整數型別，試試看加上各種修飾會將 intNum 轉為什麼 type。 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctypeinfo\u003e using namespace std; int main() { string num = \"1234\"; int intNum = num[0]-'0'; cout \u003c\u003c \"Type of intNum is: \" \u003c\u003c typeid(intNum).name() \u003c\u003c endl \u003c\u003c \"Type of intNum+'0' is: \" \u003c\u003c typeid(intNum+'0').name() \u003c\u003c endl \u003c\u003c \"Type of char(intNum) is: \" \u003c\u003c typeid(char(intNum)).name() \u003c\u003c endl \u003c\u003c \"Type of char(intNum)+'0' is: \" \u003c\u003c typeid(char(intNum)+'0').name() \u003c\u003c endl \u003c\u003c \"Type of to_string(intNum) is: \" \u003c\u003c typeid(to_string(intNum)).name() \u003c\u003c endl; } Type of intNum is: i Type of intNum+'0' is: i Type of char(intNum) is: c Type of char(intNum)+'0' is: i Type of to_string(intNum) is: Ss 由上面輸出可知，只有直接用 to_string 轉型可以將 int 換回 string type。 但是根據這題的題意，我們希望能一一串回 string 中，下面的實驗可以告訴我們： #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctypeinfo\u003e using namespace std; int main() { string num = \"1234\"; num += 1; cout \u003c\u003c num \u003c\u003c endl; num += 2+'0'; cout \u003c\u003c num \u003c\u003c endl; num += char(3); cout \u003c\u003c num \u003c\u003c endl; num += char(4)+'0'; cout \u003c\u003c num \u003c\u003c endl; num += to_string(5); cout \u003c\u003c num \u003c\u003c endl; } 1234 12342 12342 123424 1234245 在 int 或 char 後面加上 +'0' 即可串上 string，當然最保險且最簡單的作法當然是強轉型成 to_string 啦。 ","date":"2021-10-04","objectID":"/posts/cpp/cpp_int_to_string/:0:0","tags":["c++"],"title":"【C++】int to string \u0026 string to int","uri":"/posts/cpp/cpp_int_to_string/"},{"categories":["Computer System"],"content":"Reference https://www.delftstack.com/zh-tw/howto/cpp/how-to-convert-int-to-string-in-cpp/ ","date":"2021-10-04","objectID":"/posts/cpp/cpp_int_to_string/:1:0","tags":["c++"],"title":"【C++】int to string \u0026 string to int","uri":"/posts/cpp/cpp_int_to_string/"},{"categories":["leetcode"],"content":"題目 Problem Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. Example 1: Input: s = \"leetcode\" Output: 0 Example 2: Input: s = \"loveleetcode\" Output: 2 Example 3: Input: s = \"aabb\" Output: -1 Constraints: 1 $\\leq$ s.length $\\leq$ 105 s consists of only lowercase English letters. ","date":"2021-09-27","objectID":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/:1:0","tags":["hash table","string","queue","counting","easy","c++"],"title":"LeetCode 387. First Unique Character in a String 解題紀錄","uri":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/"},{"categories":["leetcode"],"content":"解法 沿著字串一一計算每個字母出現的次數，並記錄在 mp 中，再依照 s 中出現的時間遍歷 mp 檢查是否有只出現過一次的字母。 ","date":"2021-09-27","objectID":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/:2:0","tags":["hash table","string","queue","counting","easy","c++"],"title":"LeetCode 387. First Unique Character in a String 解題紀錄","uri":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/"},{"categories":["leetcode"],"content":"解法一 int firstUniqChar(string s) { unordered_map\u003cchar, int\u003e mp; // 計算每個 char 出現的次數 for(auto i:s) { mp[i]++; } // 每一個 char 遍歷尋找只出現一次的 char for(auto i=0; i\u003cs.size(); i++) { if(mp[s[i]]==1) return i; } return -1; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2021-09-27","objectID":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/:2:1","tags":["hash table","string","queue","counting","easy","c++"],"title":"LeetCode 387. First Unique Character in a String 解題紀錄","uri":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/"},{"categories":["leetcode"],"content":"解法二 一樣沿著 s 檢查每個字母是否有出現過，若有出現過的話，在 mp[i] 的位置將次數記錄直接改成 INT_MAX；反之則紀錄這個字母出現過的位置。 再搜尋 mp 中最小的值，即為第一個遇到的 unique number。 int firstUniqChar(string s) { unordered_map\u003cchar, int\u003e mp; int ans = INT_MAX; for(auto i=0; i\u003cs.size(); i++) { // 沒看過這個字母，紀錄出現的位置 (index) if(mp.find(s[i]) == mp.end()) { mp[s[i]] = i; } // 有看過這個字母了，出現位置改成 INT_MAX else { mp[s[i]] = INT_MAX; } } // 尋找最小的 index 值 for(auto i:mp) { ans = min(i.second, ans); } // 若最小 index 為 INT_MAX，表示每個 char 都重複出現過 return (ans==INT_MAX) ? -1:ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2021-09-27","objectID":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/:2:2","tags":["hash table","string","queue","counting","easy","c++"],"title":"LeetCode 387. First Unique Character in a String 解題紀錄","uri":"/posts/leetcode/leetcode_387_first_unique_character_in_a_string/"},{"categories":["leetcode"],"content":"題目 Problem Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing. For example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\". Return the resulting string. Example 1: Input: word = \"abcdefd\", ch = \"d\" Output: \"dcbaefd\" Explanation: The first occurrence of “d” is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is “dcbaefd”. Example 2: Input: word = \"xyxzxe\", ch = \"z\" Output: \"zxyxxe\" Explanation: The first and only occurrence of “z” is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is “zxyxxe”. Example 3: Input: word = \"abcd\", ch = \"z\" Output: \"abcd\" Explanation: “z” does not exist in word. You should not do any reverse operation, the resulting string is “abcd”. Constraints: 1 $\\leq$ word.length $\\leq$ 250 word consists of lowercase English letters. ch is a lowercase English letter. ","date":"2021-09-17","objectID":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/:1:0","tags":["two pointers","string","easy","c++"],"title":"LeetCode 2000. Reverse Prefix of Word 解題紀錄","uri":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/"},{"categories":["leetcode"],"content":"想法 Find the position of ch, and then swap all the characters from 0 to the position of ch STL trick in two lines: find the position of ch, then reverse. ","date":"2021-09-17","objectID":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/:2:0","tags":["two pointers","string","easy","c++"],"title":"LeetCode 2000. Reverse Prefix of Word 解題紀錄","uri":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/"},{"categories":["leetcode"],"content":"解法 ","date":"2021-09-17","objectID":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/:3:0","tags":["two pointers","string","easy","c++"],"title":"LeetCode 2000. Reverse Prefix of Word 解題紀錄","uri":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/"},{"categories":["leetcode"],"content":"解法一 交換文字片段 string reversePrefix(string word, char ch) { // get the position of 'ch' int ch_pos = word.find(ch); // if 'ch' is not in the string, return it if(ch_pos == -1) { return word; } // if 'ch' exists in the string, swap those characters from index 0 to ch_pos // mind that we only have to swap ch_pos/2 times for(auto i=0; i\u003c=ch_pos/2; i++) { int temp = word[ch_pos-i]; word[ch_pos-i] = word[i]; word[i] = temp; } return word; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-09-17","objectID":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/:3:1","tags":["two pointers","string","easy","c++"],"title":"LeetCode 2000. Reverse Prefix of Word 解題紀錄","uri":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/"},{"categories":["leetcode"],"content":"解法二 string reversePrefix(string word, char ch) { reverse(word.begin(), word.begin()+word.find(ch)+1); return word; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-09-17","objectID":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/:3:2","tags":["two pointers","string","easy","c++"],"title":"LeetCode 2000. Reverse Prefix of Word 解題紀錄","uri":"/posts/leetcode/leetcode_2000_reverse_prefix_of_word/"},{"categories":["leetcode"],"content":"題目 Problem You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range $[1, 100]$. 0 $\\leq$ Node.val $\\leq$ 9 It is guaranteed that the list represents a number that does not have leading zeros. ","date":"2021-09-13","objectID":"/posts/leetcode/leetcode_2_add_two_numbers/:1:0","tags":["linked list","math","recursion","easy","c++"],"title":"LeetCode 2. Add Two Numbers 解題紀錄","uri":"/posts/leetcode/leetcode_2_add_two_numbers/"},{"categories":["leetcode"],"content":"想法 Info 使用指標新增 ListNode _ ans = new ListNode(0); ListNode _ temp = ans; 最後只要 return ans→next; ","date":"2021-09-13","objectID":"/posts/leetcode/leetcode_2_add_two_numbers/:2:0","tags":["linked list","math","recursion","easy","c++"],"title":"LeetCode 2. Add Two Numbers 解題紀錄","uri":"/posts/leetcode/leetcode_2_add_two_numbers/"},{"categories":["leetcode"],"content":"解法 ","date":"2021-09-13","objectID":"/posts/leetcode/leetcode_2_add_two_numbers/:3:0","tags":["linked list","math","recursion","easy","c++"],"title":"LeetCode 2. Add Two Numbers 解題紀錄","uri":"/posts/leetcode/leetcode_2_add_two_numbers/"},{"categories":["leetcode"],"content":"解法一 就像 66. Plus One 這題一樣，需要一個 carry 記住進位。 如果 l1 或 l2 有人的 node 為 NULL 時要特別設計算值為 0。 若 l1 或 l2 為 NULL，代表下一個點一定也是 NULL。 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return cal(l1, l2, 0); } ListNode* cal(ListNode* l1, ListNode* l2, int carry) { if(!l1 \u0026\u0026 !l2 \u0026\u0026 !carry) return NULL; int sum = (l1? l1-\u003eval:0) + (l2? l2-\u003eval:0) + carry; ListNode* ans = new ListNode(sum%10); ans-\u003enext = cal(l1?(l1-\u003enext):NULL, l2?(l2-\u003enext):NULL, sum/10); return ans; } Time complexity: $\\mathcal{O}(m+n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-09-13","objectID":"/posts/leetcode/leetcode_2_add_two_numbers/:3:1","tags":["linked list","math","recursion","easy","c++"],"title":"LeetCode 2. Add Two Numbers 解題紀錄","uri":"/posts/leetcode/leetcode_2_add_two_numbers/"},{"categories":["leetcode"],"content":"解法二 如果 l1、l2、carry 其中任一具有值，則繼續生成新點。 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode * ans = new ListNode(0); ListNode * temp = ans; int carry = 0; while(l1 || l2 || carry) { carry += (l1 ? l1-\u003eval : 0) + (l2 ? l2-\u003eval : 0); temp-\u003enext = new ListNode(carry%10); temp = temp-\u003enext; carry /= 10; if(l1) l1 = l1-\u003enext; if(l2) l2 = l2-\u003enext; } return ans-\u003enext; } Time complexity: $\\mathcal{O}(m+n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2021-09-13","objectID":"/posts/leetcode/leetcode_2_add_two_numbers/:3:2","tags":["linked list","math","recursion","easy","c++"],"title":"LeetCode 2. Add Two Numbers 解題紀錄","uri":"/posts/leetcode/leetcode_2_add_two_numbers/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer $n$, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if $i$ is divisible by 3 and 5. answer[i] == \"Fizz\" if i is divisible by 3. answer[i] == \"Buzz\" if i is divisible by 5. answer[i] == i (as a string) if none of the above conditions are true. Example 1: Input: n = 3 Output: [\"1\",\"2\",\"Fizz\"] Example 2: Input: n = 5 Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"] Example 3: Input: n = 15 Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"] Constraints: 1 $\\leq$ n $\\leq 10^4$ ","date":"2021-05-19","objectID":"/posts/leetcode/leetcode_412_fizz_buzz/:1:0","tags":["math","string","simulation","easy","c++"],"title":"LeetCode 412. Fizz Buzz 解題紀錄","uri":"/posts/leetcode/leetcode_412_fizz_buzz/"},{"categories":["leetcode"],"content":"想法 依序插入每一元素的值，如果遇到 3、5、15 的倍數，換成插入 “Fizz”、“Buzz”、“FizzBuzz” to_string() 想要將數字強轉成 string 時，使用 std::to_string()，卻一直出現 ’to_string’: 找不到識別項，在前方記得要先加上 include #include \u003cstring\u003e ","date":"2021-05-19","objectID":"/posts/leetcode/leetcode_412_fizz_buzz/:2:0","tags":["math","string","simulation","easy","c++"],"title":"LeetCode 412. Fizz Buzz 解題紀錄","uri":"/posts/leetcode/leetcode_412_fizz_buzz/"},{"categories":["leetcode"],"content":"解法 ","date":"2021-05-19","objectID":"/posts/leetcode/leetcode_412_fizz_buzz/:3:0","tags":["math","string","simulation","easy","c++"],"title":"LeetCode 412. Fizz Buzz 解題紀錄","uri":"/posts/leetcode/leetcode_412_fizz_buzz/"},{"categories":["leetcode"],"content":"解法一 vector\u003cstring\u003e fizzBuzz(int n) { vector\u003cstring\u003e ans(n); for(auto i=1; i\u003c=n; i++) { // 15 的倍數為 \"FizzBuzz\" if(i%15 == 0) { ans.push_back(\"FizzBuzz\"); } // 5 的倍數為 \"Buzz\" else if(i%5 == 0) { ans.push_back(\"Buzz\"); } // 3 的倍數為 \"Fizz\" else if(i%5 == 0) { ans.push_back(\"Fizz\"); } // 依序填入值 else { ans.push_back(to_string(i)); } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2021-05-19","objectID":"/posts/leetcode/leetcode_412_fizz_buzz/:3:1","tags":["math","string","simulation","easy","c++"],"title":"LeetCode 412. Fizz Buzz 解題紀錄","uri":"/posts/leetcode/leetcode_412_fizz_buzz/"},{"categories":["leetcode"],"content":"解法二 vector\u003cstring\u003e fizzBuzz(int n) { vector\u003cstring\u003e ans(n); // 依序填入值 for(auto i=1; i\u003c=n; i++) { ans[i-1] = to_string(i); } // 3 的倍數為 \"Fizz\" for(auto i=2; i\u003cn; i+=3) { ans[i] = \"Fizz\"; } // 5 的倍數為 \"Buzz\" for(auto i=4; i\u003cn; i+=5) { ans[i] = \"Buzz\"; } // 15 的倍數為 \"FizzBuzz\" for(auto i=14; i\u003cn; i+=15) { ans[i] = \"FizzBuzz\"; } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. 兩種做法的時間、空間複雜度都是 $O(n)$，哪個比較好呢？ 做 除法/mod 時，對 CPU 相對來說是相當耗時的。 反而是多次地在 memory 做寫入還比較好。 Doing extra writes is better than expensive arithmetic. ","date":"2021-05-19","objectID":"/posts/leetcode/leetcode_412_fizz_buzz/:3:2","tags":["math","string","simulation","easy","c++"],"title":"LeetCode 412. Fizz Buzz 解題紀錄","uri":"/posts/leetcode/leetcode_412_fizz_buzz/"},{"categories":["leetcode"],"content":"Reference https://www.cplusplus.com/reference/string/to_string/ ","date":"2021-05-19","objectID":"/posts/leetcode/leetcode_412_fizz_buzz/:4:0","tags":["math","string","simulation","easy","c++"],"title":"LeetCode 412. Fizz Buzz 解題紀錄","uri":"/posts/leetcode/leetcode_412_fizz_buzz/"},{"categories":["leetcode"],"content":"題目 Problem You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true *if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings*. Otherwise, return false. Example 1: Input: s1 = \"bank\", s2 = \"kanb\" Output: true Explanation: For example, swap the first character with the last character of s2 to make “bank”. Example 2: Input: s1 = \"attack\", s2 = \"defend\" Output: false Explanation: It is impossible to make them equal with one string swap. Example 3: Input: s1 = \"kelb\", s2 = \"kelb\" Output: true Explanation: The two strings are already equal, so no string swap operation is required. Constraints: 1 $\\leq$ s1.length, s2.length $\\leq$ 100 s1.length == s2.length s1 and s2 consist of only lowercase English letters. ","date":"2021-05-10","objectID":"/posts/leetcode/leetcode_1790_check_if_one_string_swap_can_make_strings_equal/:1:0","tags":["hash table","string","counting","easy","c++"],"title":"LeetCode 1790. Check if One String Swap Can Make Strings Equal 解題紀錄","uri":"/posts/leetcode/leetcode_1790_check_if_one_string_swap_can_make_strings_equal/"},{"categories":["leetcode"],"content":"想法 題目希望兩個 string 相同，給出的條件是：最多做一次字元交換。 如果兩個 string 一開始就相同，那恭喜，直接就保送為 true。 若兩個 string 有一個位置不同，無法單靠 swap 字元得到相同的 string。 若有 s1 和 s2 中兩個位置不同呢？很好，檢查一下做一次交換字元後兩個 string 是否相同即可！ ","date":"2021-05-10","objectID":"/posts/leetcode/leetcode_1790_check_if_one_string_swap_can_make_strings_equal/:2:0","tags":["hash table","string","counting","easy","c++"],"title":"LeetCode 1790. Check if One String Swap Can Make Strings Equal 解題紀錄","uri":"/posts/leetcode/leetcode_1790_check_if_one_string_swap_can_make_strings_equal/"},{"categories":["leetcode"],"content":"解法 bool areAlmostEqual(string s1, string s2) { // 兩個 string 長度不一致 if(s1.size() != s2.size()) return 0; // 紀錄兩個 string 不同之處 vector\u003cint\u003e mp; for(auto i=0; i\u003cs1.size(); i++) { if(s1[i] != s2[i]) { mp.push_back(i); } } // 兩個 string 完全相同 if(!mp.size()) return 1; // 兩個 string 共有兩處不同 if(mp.size() == 2) { // 確定互換後可以達到 s1 == s2 if( s1[mp[0]] == s2[mp[1]] \u0026\u0026 s1[mp[1]] == s2[mp[0]]) { return 1; } } return 0; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2021-05-10","objectID":"/posts/leetcode/leetcode_1790_check_if_one_string_swap_can_make_strings_equal/:3:0","tags":["hash table","string","counting","easy","c++"],"title":"LeetCode 1790. Check if One String Swap Can Make Strings Equal 解題紀錄","uri":"/posts/leetcode/leetcode_1790_check_if_one_string_swap_can_make_strings_equal/"},{"categories":["leetcode"],"content":"Amazon Online Assessment (OA) - Roll Dice Complexity: medium Date: October 7, 2021 No: 0 Status: Completed Tags: array, hash table url: https://algo.monster/problems/roll_dice ","date":"2021-05-03","objectID":"/posts/amazon_online_assessment-roll_dice/:0:0","tags":["medium","c++"],"title":"Amazon Online Assessment (OA) - Roll Dice 解題紀錄","uri":"/posts/amazon_online_assessment-roll_dice/"},{"categories":["leetcode"],"content":"Amazon Online Assessment (OA) - Roll Dice stackoverflow 也有人問過 Given N dices each face ranging from 1 to 6, return the minimum number of rotations necessary for each dice show the same face. Notice in one rotation you can rotate the dice to the adjacent face. For example, you can rotate the dice shows 1 to show 2, 3, 4, or 5. But to make it show 6, you need two rotations. Input The input consists of three arguments: N: a list of integer represent dices each face ranging from 1 to 6 Output return the minimum number of rotations necessary for each dice show the same face Example 1: Input: N = [6, 5, 4] Output: 2 Example 2: Input: N = [6, 6, 1] Output: 2 Example 3: Input: N = [6, 1, 5, 4] Output: 3 ","date":"2021-05-03","objectID":"/posts/amazon_online_assessment-roll_dice/:1:0","tags":["medium","c++"],"title":"Amazon Online Assessment (OA) - Roll Dice 解題紀錄","uri":"/posts/amazon_online_assessment-roll_dice/"},{"categories":["leetcode"],"content":"思路： 先統計一下 1~6 點各擲出幾次 假設每個點都需要花一次翻面次數就能翻到大家都一樣的 理想目標，總花費應該等於擲骰子的次數 事與願違，我們需要找出真正能被骰子擲出的 目標，這個目標值的範圍是 1~6 之間。我們要在所有目標值造成的花費中尋找出最便宜的方法。 假設 input = [1, 2, 3, 4, 5, 6] 如果要計算總花費， 當目標值為 1， 1 面翻到 1 的次數 + 2 面翻到 1 的次數 + 3 面翻到 1 的次數 + 4 面翻到 1 的次數 + 5 面翻到 1 的次數 + 6 的翻到 1 的次數 = 0 + 1 + 1 + 1 + 1 + 2 當目標值為 2， 1 面翻到 2 的次數 + 2 面翻到 2 的次數 + 3 面翻到 2 的次數 + 4 面翻到 2 的次數 + 5 面翻到 2 的次數 + 6 面翻到 2 的次數 = 1 + 0 + 1 + 1 + 2 + 1 當目標值為 3， 1 面翻到 3 的次數 + 2 面翻到 3 的次數 + 3 面翻到 3 的次數 + 4 面翻到 3 的次數 + 5 面翻到 3 的次數 + 6 面翻到 3 的次數 = 1 + 1 + 0 + 2 + 1 + 1 發現到 當 目標值 移動到該數字時，它自己就是目標，所以它的總花費會比自己原本要移動到 理想目標 少一步。 而現在 目標值 的背面，也就是在骰子上我們看到 1 面背面是 6、2 面背面是 5、3 面背面是 4，這些背面的值要再比原本到 理想目標 多一步。 既不是 目標值 也不是 目標值 背面的數字，真正的符合了原先 理想目標 的假設 ⇒ 只需要一步就可以翻到目標的數字。如果大家都只需要一步，那是不是可以先省下這部分的計算，最後再加上就好了呢？ class Solution { public: int minCostofRotation(vector\u003cint\u003e\u0026 dices) { unordered_map\u003cint, int\u003e mp; int cost = INT_MAX; // step 1 for(auto \u0026i:dices) { mp[i]++; } // step 3 for(auto i=1; i\u003c=6; i++) { cost = min(cost, mp[7-i]-mp[i]); } // step 2 return cost + dices.size(); } }; Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. 很完整能直接跑出結果的解法 (但我只想看方法 oao) #include \u003calgorithm\u003e // copy #include \u003ciostream\u003e // cin, cout #include \u003citerator\u003e // back_inserter, istream_iterator #include \u003csstream\u003e // istringstream #include \u003cstring\u003e // getline, string #include \u003cvector\u003e // vector #include \u003climits.h\u003e //INT_MAX using namespace std; int number_of_rotations(vector\u003cint\u003e dices) { // WRITE YOUR BRILLIANT CODE HERE unordered_map\u003cint, int\u003e mp; int cost = INT_MAX; for(auto \u0026i:dices) { mp[i]++; } for(auto i=1; i\u003c=6; i++) { cost = min(cost, mp[7-i]-mp[i]); } return cost + dices.size(); } template\u003ctypename T\u003e vector\u003cT\u003e get_words() { string line; getline(cin, line); istringstream ss{line}; vector\u003cT\u003e v; copy(istream_iterator\u003cT\u003e{ss}, istream_iterator\u003cT\u003e{}, back_inserter(v)); return v; } int main() { vector\u003cint\u003e dice = get_words\u003cint\u003e(); int res = number_of_rotations(dice); cout \u003c\u003c res \u003c\u003c '\\n'; } ","date":"2021-05-03","objectID":"/posts/amazon_online_assessment-roll_dice/:1:1","tags":["medium","c++"],"title":"Amazon Online Assessment (OA) - Roll Dice 解題紀錄","uri":"/posts/amazon_online_assessment-roll_dice/"},{"categories":["leetcode"],"content":"題目 Problem You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Example 1: Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2: Input: list1 = [], list2 = [] Output: [] Example 3: Input: list1 = [], list2 = [0] Output: [0] Constraints: The number of nodes in both lists is in the range $[0, 50]$. -100 $\\leq$ Node.val $\\leq$ 100 Both list1 and list2 are sorted in non-decreasing order. ","date":"2021-01-04","objectID":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/:1:0","tags":["linked list","recursion","easy","c++"],"title":"LeetCode 21. Merge Two Sorted Lists 解題紀錄","uri":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/"},{"categories":["leetcode"],"content":"想法 ListNode 的新增在 這邊，如果非必要，我還是比較喜歡用指標，光是不用一直切換 node.next 還是 node-\u003enext 就省很多力氣了 😊 概念類似於 Merge Sorted Array，但是 Linked List 不能偷吃步從最末端開始 sort。 從兩個 Linked List 最前端一一比較、放入新的 Linked List newList。 最後別忘記把剩下不需要比較的 nodes 放進排序好的 newList 啊。 ","date":"2021-01-04","objectID":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/:2:0","tags":["linked list","recursion","easy","c++"],"title":"LeetCode 21. Merge Two Sorted Lists 解題紀錄","uri":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/"},{"categories":["leetcode"],"content":"解法 ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { // 任一 list 為空 if(!list1) return list2; if(!list2) return list1; // 新增一個 ListNode 並以指標指向它 (方便待會回傳) ListNode *newList = new ListNode(0); // 各種指向工作位置的指標 ListNode *l1 = list1, *l2 = list2, *n = newList; // l1 和 l2 還需要比較的話... while(l1 \u0026\u0026 l2) { if(l1-\u003eval \u003e l2-\u003eval) { n-\u003enext = l2; l2 = l2-\u003enext; } else { n-\u003enext = l1; l1 = l1-\u003enext; } n = n-\u003enext; } // 剩下 l2 直接貼上 if(l2) { n-\u003enext = l2; } // 剩下 l1 直接貼上 if(l1) { n-\u003enext = l1; } return newList-\u003enext; } ","date":"2021-01-04","objectID":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/:3:0","tags":["linked list","recursion","easy","c++"],"title":"LeetCode 21. Merge Two Sorted Lists 解題紀錄","uri":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/"},{"categories":["leetcode"],"content":"解法二 Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2021-01-04","objectID":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/:3:1","tags":["linked list","recursion","easy","c++"],"title":"LeetCode 21. Merge Two Sorted Lists 解題紀錄","uri":"/posts/leetcode/leetcode_21_merge_two_sorted_lists/"},{"categories":["leetcode"],"content":"題目 Problem A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false. Example 1: Input: arr = [3,5,1] Output: true Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements. Example 2: Input: arr = [1,2,4] Output: false Explanation: There is no way to reorder the elements to obtain an arithmetic progression. Constraints: 2 $\\leq$ arr.length $\\leq$ 1000 $-10^6 \\leq$ arr[i] $\\leq 10^6$ ","date":"2020-03-30","objectID":"/posts/leetcode/leetcode_1502_can_make_arithmetic_progression_from_sequence/:1:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 1502. Can Make Arithmetic Progression From Sequence 解題紀錄","uri":"/posts/leetcode/leetcode_1502_can_make_arithmetic_progression_from_sequence/"},{"categories":["leetcode"],"content":"想法 整組 vector 依照大小排列，兩兩檢查中間的間隙是否等大。 ","date":"2020-03-30","objectID":"/posts/leetcode/leetcode_1502_can_make_arithmetic_progression_from_sequence/:2:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 1502. Can Make Arithmetic Progression From Sequence 解題紀錄","uri":"/posts/leetcode/leetcode_1502_can_make_arithmetic_progression_from_sequence/"},{"categories":["leetcode"],"content":"解法 bool canMakeArithmeticProgression(vector\u003cint\u003e\u0026 arr) { sort(arr.begin(), arr.end()); auto t = arr[1] - arr[0]; for(auto i=arr.size()-1; i\u003e1; i--) { if(arr[i] - arr[i-1] != t) { return 0; } } return 1; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2020-03-30","objectID":"/posts/leetcode/leetcode_1502_can_make_arithmetic_progression_from_sequence/:3:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 1502. Can Make Arithmetic Progression From Sequence 解題紀錄","uri":"/posts/leetcode/leetcode_1502_can_make_arithmetic_progression_from_sequence/"},{"categories":["Physiology"],"content":"眼球構造 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:1:0","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"外層 Fibrous tunic 緻密結締組織 角膜 cornea 功能為聚光 鞏膜 sclera 佔眼球後半 5/6 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:1:1","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"中層 Vascular tunic 虹彩 Iris 區分前房及後房 中央開口（瞳孔 pupil）藉由平滑肌控制 功能為調整光量 睫狀體 ciliary body 睫狀肌 ciliary muscle：調整 lens 厚薄 睫狀突 ciliary processes：分泌房水 脈絡叢 choroid plexus：含黑色素可吸收光線，避免光線在眼內散開而造成視覺混淆、血管提供營養 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:1:2","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"內層 Retina 共 10 層神經組織層： 色素上皮層 → 錐桿細胞層 → 外限制膜 → 外核膜 → 外叢狀層 → 內核層 → 內叢狀層 → 神經節細胞層 → 視神經纖維層 → 內限制膜 皮素上皮 Pigment epithelium 會吞吃錐桿細胞外節內的膜狀板 membranous discs，維持其光感受活性。 光感受器位於此層，如下圖1，分為 錐細胞 cone：掌管色彩 桿細胞 rod： 掌管亮度 錐細胞與桿細胞 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:1:3","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"交感、副交感 n 對視覺的調控 看遠：交感神經興奮 → 睫狀肌鬆弛 → 懸韌帶拉緊 → 水晶體變扁平 → 減小光線的折射曲率 → 焦距在後 看近（眼球的調適 accomadation）：副交感神經興奮 → 睫狀肌 ciliary muscle 收縮 → 懸韌帶放鬆 → 水晶體 lens 變厚 → 加大光線的折射曲率 → 焦距在前 調適 水晶體增加曲率及維持短距離視物的聚焦能力 肌肉 脈絡膜的部位 交感神經興奮 副交感神經興奮 放射肌 radial muscle 虹彩 Iris 收縮（散瞳 mydriasis） 環狀肌 circular muscle 虹彩 Iris 收縮（縮瞳 moisis） 睫狀肌 ciliary muscle 睫狀肌 ciliary body 鬆弛（導致水晶體變薄） 收縮（導致水晶體變厚） 睫狀肌 睫狀肌在交感與副交感神經皆有作用 光反射（縮瞳）： 光線 → 光接收器（錐桿細胞） → 雙極細胞 bipolar cell → 神經節細胞 ganglion cell → 視神經 CN 2 → 中腦前蓋核 → 中腦 E-W 核 → 動眼神經 CN 3 → Ciliary ganglion → Iris → Circular muscle contraction → 縮瞳 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:2:0","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"光接受器（錐細胞、桿細胞）比較 錐狀細胞 cone 桿狀細胞 rod 數目 少，但有三種錐狀細胞，分別可對紅綠藍產生反應 多，只有一種桿狀細胞 分布 中央小窩（黃斑區） 全部視網膜 對光敏感度 低（對強光敏感） 高（對弱光敏感） 解像度 高 低 功能 色彩明亮視覺 黑白暗視覺 感光色素 photopigment 多寡 錐狀細胞 cones 的感光色素是碘視紫 iodopsin 量很少 桿狀細胞 rods 的感光色素是視紫 rhodopsin，量很多 黃斑 中央小窩 fovea centrails（即黃斑 macula lutea），這是視覺最佳處，只有錐狀細胞 cones，沒有桿狀細胞 rods 和血管。 視神經盤 視神經盤 optic disc 就是視乳頭 blink spot，因為沒有 cones 和 rods，所以無法成像。 錐狀細胞 如果某藥物破壞了視網膜內所有錐狀細胞 cone cells，在低亮度時，視覺正常；在高亮度時，無法產生清楚的視覺影像；在極亮的狀態下，無法產生視覺。 辨色力 如果從小能看到東西卻無法辨色，有可能的原因是：錐狀細胞 cone cells 上 cGMP 控制型離子通道 cGMP-gated channel 的 alpha 次單元發生失去功能。 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:3:0","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"感光色素 photopigment ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:4:0","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"碘色素 iodopsin 錐狀細胞 cones 的感光色素是碘視紫 iodopsin，其成分是由光視質 photopsin + 視黃醛 11-cis retinal 組成 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:4:1","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"視紫 rhodopsin 桿狀細胞 rods 的感光色素是視紫 rhodopsin。視紫成分為暗視質 scotopsin + 視黃醛 11-cis retinal 組成 感光色素的製造 感光色素的製造主要在光接受器的內節 inner segment of photoreceptor 完成。 感光色素的功能 感光色素的功能有直接關係的有：光適應 （視紫分解）、暗適應 （視紫合成）、色盲（錐狀細胞碘視紫）、夜盲（缺乏 vitamin A 而無法形成視黃醛，繼而無法形成視紫） ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:4:2","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"光適應及暗適應 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:5:0","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"光適應 light adaptation：視紫分解 當人突然從黑暗處走到明亮處，視網膜慢慢習慣光線的現象 視紫 rhodopsin 分解並轉變為 vitamin A 當光線照射到桿狀細胞時，視紫分解而發生電位變化。因為細胞內之視紫 rhodopsin 大量減少，導致對光敏感性大大減低 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:5:1","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"暗適應 dark adaptation：視紫合成 當人突然從明亮處走到黑暗處，視網膜慢慢習慣黑暗的現象 vitamin A 被轉變為視紫 rhodopsin 合成 因為細胞內之視紫 rhodopsin 大量增加，導致對光敏感性增加 暗適應 視網膜在完全暗適應下，對光的敏感性比在光適應下大上 10000 倍，加上瞳孔開大進入眼內光量增多，其對光之敏感性要比光適應大 100 萬倍。在暗適應下只有光覺而無形覺和色彩覺。 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:5:2","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"視覺傳導路徑 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:6:0","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"整體路徑 光線 → 光接受器（錐桿細胞的 outer segment 膜上的 rhodopsin，rhodopsin produced conformational Change from 11-cis-retinal to all-trans-retinal） → 活化傳導素，transducin = G 蛋白 → 活化磷酸雙脂酶 Phosphodiesterase = PDE → 使 cGMP 量減少 → Na+、Ca2+ 通道關閉 → 產生過極化 Hyperpolarization → 使神經傳遞物 Glutamate 釋放減少 → 無法興奮雙極細胞 bipolar cell → 無法抑制神經節細胞 ganglion cell → 反而使 ganglion cell 興奮而產生動作電位 → 傳至視神經 optic nerve → 視交叉 optic chiasm → 視徑 optic tract → 視丘外膝狀體 lateral geniculus of thalamus → 視放射 optic radiation → 大腦枕葉 17 區 黑暗中的視覺傳遞 黑暗 → cGMP 量上升 → Outer segment 膜上的 Na+、Ca2+ 通道開啟 → Na+、Ca2+ 通道 Influx → 產生去極化 depolarization → 使神經傳導物：Glutamate 釋放增加 ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:6:1","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["Physiology"],"content":"單一視野路徑 大腦中的視野路徑 如上圖2，可整理出： 右眼外側視野 由右眼左（內）側視網膜接收，並經由 right optic nerve 傳遞，在 optic chiasm 交叉，然後經由 left optic tract 傳至 left thalamus，再經由 left optic radiation → left side 大腦視覺皮質區（枕葉 17 區） 右眼內側視野 由右眼右（外）側視網膜接收，並經由 right optic nerve 傳遞，並沒有在 optic chiasm 交叉，所以仍經由 right optic tract 傳至 right thalamus，再經由 right optic radiation → right side 大腦視覺皮質區（枕葉 17 區） 左眼外側視野 由左眼右（內）側視網膜接收，並經由 left optic nerve 傳遞，在 optic chiasm 交叉，然後經由 right optic tract 傳至 right thalamus，再經由 right optic radiation → right side 大腦視覺皮質區（枕葉 17 區） 左眼內側視野 由左眼左（外）側視網膜接收，並經由 left optic nerve 傳遞，並沒有在 optic chiasm 交叉，然後經由 left optic tract 傳至 left thalamus，再經由 left optic radiation → left side 大腦視覺皮質區（枕葉 17 區） The eye link ↩︎ Pattern Formation in the brain link ↩︎ ","date":"2020-02-06","objectID":"/posts/graphics/visualization_physiology/:6:2","tags":["visual"],"title":"【生理】筆記 ─ 視覺與眼球構造","uri":"/posts/graphics/visualization_physiology/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0. Example 1: Input: nums = [2,1,2] Output: 5 Example 2: Input: nums = [1,2,1] Output: 0 Constraints: 3 $\\leq$ nums.length $\\leq$ 104 1 $\\leq$ nums[i] $\\leq$ 106 ","date":"2020-01-27","objectID":"/posts/leetcode/leetcode_976_largest_perimeter_triangle/:1:0","tags":["array","math","greedy","sorting","easy","c++"],"title":"LeetCode 976. Largest Perimeter Triangle 解題紀錄","uri":"/posts/leetcode/leetcode_976_largest_perimeter_triangle/"},{"categories":["leetcode"],"content":"想法 題目希望找出組成「最大面積」的三角形邊常，理論上只要三條邊長是前三大即可。 由於要組成三角形，還需要依照三角不等式檢查是否符合「三角形任兩邊相加必大於第三邊」。 ","date":"2020-01-27","objectID":"/posts/leetcode/leetcode_976_largest_perimeter_triangle/:2:0","tags":["array","math","greedy","sorting","easy","c++"],"title":"LeetCode 976. Largest Perimeter Triangle 解題紀錄","uri":"/posts/leetcode/leetcode_976_largest_perimeter_triangle/"},{"categories":["leetcode"],"content":"解法 int largestPerimeter(vector\u003cint\u003e\u0026 nums) { // 由小排到大 sort(nums.begin(), nums.end()); // 從最有可能的最長元素開始 for(auto i=nums.size()-1; i\u003e=2; i--) { // 根據三角不等式確認是否能組成 if(nums[i] \u003c nums[i-1]+nums[i-2]) { return nums[i] + nums[i-1] + nums[i-2]; } } return 0; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2020-01-27","objectID":"/posts/leetcode/leetcode_976_largest_perimeter_triangle/:3:0","tags":["array","math","greedy","sorting","easy","c++"],"title":"LeetCode 976. Largest Perimeter Triangle 解題紀錄","uri":"/posts/leetcode/leetcode_976_largest_perimeter_triangle/"},{"categories":["Graphics"],"content":"成功 trace 過球、三角形之後，我們想要試著畫出更複雜的圖片，這時候就需要幫程式加入讀取 .obj 和 .mtl 的功能。 當然，這些都是不用背起來的內容，更有許多 load .obj 的現成工具，這篇的目的在於渲染出奇怪的影像時，能順利肉眼 parse 出一點問題。 ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:0:0","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"obj 格式 obj 檔案使用記事本開啟後，長成下面這副模樣。 o Plane v -0.5 -0.5 0.0 v -0.5 -0.5 1.0 v 0.5 -0.5 1.0 v 0.5 -0.5 0.0 vn 0.0000 -1.0000 0.0000 usemtl Reflection001 s off f 2//1 3//1 1//1 f 4//1 1//1 3//1 每一行視為一個物件。 開頭都有一組英文字母，告訴電腦「這一行的物件屬性」，v 表示這一行是一個 vertex（頂點） 屬性的物件。 字母後面接著一串數字，就是這個物件的內容。 字母 英文全名 意義 v vertex 頂點座標 vn vertex normal 法向量座標 vt vertex texture 紋理座標 f surface 面 g group 群組 ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:1:0","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"v 頂點 以第二行輸入為例： 開頭 v 宣告物件為一個頂點，頂點座標為 ( -0.5 -0.5 0.0 ) v -0.5 -0.5 0.0 ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:1:1","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"vn 法向量 每個平面圖形都會擁有一個法向量，在 obj 檔案中，已經幫我們算好了，待會一一對應即可。 vn 0.0000 -1.0000 0.0000 ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:1:2","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"f 面 有了頂點之後，我們便可以組成面，obj 檔案中的面的基礎形狀是三角形。 如下，我們可以看到第九行第一個數字 2，表示第二個 v 物件，為頂點 (-0.5 -0.5 0.0)。 雙斜線後的 1，表示這個面的法向量是第一個 vn 物件。 f 2//1 3//1 1//1 用白話文表示： ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:1:3","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"用 C++ 讀取 obj 了解了 obj 檔案的結構後，再來思考怎麼讀取。 原本想要使用 getline 逐行讀取，但是讀到面的時候會有雙斜線的問題，故採用 fscanf 來進行。 首先，宣告儲存各物件的 class。 其中，一個面只有一個法向量座標的資料，所以只有開一個 normal 的位置。 /* load \"v\" from .obj */ class cVertices { public: double x, y, z; }; /* load \"vn\" from .obj */ class cNormal { public: double x, y, z; }; /* load \"f\" from .obj */ class cSurface { public: int point1, point2, point3; int normal; }; /* Store these information into triangles */ class cTriangle { public: vec3 vertex1(x1, y1, z1), vertex2(x2, y2, z2), vertex3(x3, y3, z3); vec3 nor; // vec3 = vector in 3D space }; 第二步，根據每一行第一個字串，歸類各個物件。 while (fscanf(objfile, \"%s\", lineHeader) != EOF) { if (strcmp(lineHeader, \"v\") == 0) { fscanf(objfile, \"%lf %lf %lf\", \u0026vertices.x, \u0026vertices.y, \u0026vertices.z); vVertices.push_back(vertices); } else if (strcmp(lineHeader, \"vn\") == 0) { fscanf(objfile, \"%lf %lf %lf\", \u0026normal.x, \u0026normal.y, \u0026normal.z); vNormal.push_back(normal); } else if (strcmp(lineHeader, \"f\") == 0) { fscanf(objfile, \"%u//%u %u//%u %u//%u\", \u0026surface.point1, \u0026surface.normal, // 第一個頂點, 法向量 \u0026surface.point2, \u0026surface.normal, // 第二個頂點, 法向量 \u0026surface.point3, \u0026surface.normal); // 第三個頂點, 法向量 vSurface.push_back(surface); } } 第三步，檢查是否成功讀入各資料。 cout \u003c\u003c \"vVertices\" \u003c\u003c endl; for (unsigned i = 0 ; i \u003c vVertices.size(); i++) { cout \u003c\u003c i \u003c\u003c \" = (x, y, z) : (\" \u003c\u003c vVertices[i].x \u003c\u003c \" \" \u003c\u003c vVertices[i].y \u003c\u003c \" \" \u003c\u003c vVertices[i].z \u003c\u003c \")\" \u003c\u003c endl; } cout \u003c\u003c endl \u003c\u003c \"vNormal\" \u003c\u003c endl; for (unsigned i = 0 ; i \u003c vNormal.size(); i++) { cout \u003c\u003c i \u003c\u003c \" = (x, y, z) : (\" \u003c\u003c vNormal[i].x \u003c\u003c \" \" \u003c\u003c vNormal[i].y \u003c\u003c \" \" \u003c\u003c vNormal[i].z \u003c\u003c \")\" \u003c\u003c endl; } cout \u003c\u003c endl \u003c\u003c \"vSurface\" \u003c\u003c endl; for (unsigned i = 0 ; i \u003c vSurface.size(); i++) { cout \u003c\u003c i \u003c\u003c \" = (normal, point1, point2, point3) : (\" \u003c\u003c vSurface[i].normal \u003c\u003c \" \" \u003c\u003c vSurface[i].point1 \u003c\u003c \" \" \u003c\u003c vSurface[i].point2 \u003c\u003c \" \" \u003c\u003c vSurface[i].point3 \u003c\u003c \")\" \u003c\u003c endl; } 輸出會長這樣，可以清楚的分類頂點、法向量、面依序排列 vVertices 0 = (x, y, z) : (-0.5 -0.5 0) 1 = (x, y, z) : (-0.5 -0.5 1) 2 = (x, y, z) : (0.5 -0.5 1) 3 = (x, y, z) : (0.5 -0.5 0) vNormal 0 = (x, y, z) : (0 -1 0) vSurface 0 = (normal, point1, point2, point3) : (1 2 3 1) 1 = (normal, point1, point2, point3) : (1 4 1 3) 第四步，將讀取到的資料歸類並放入 triangle。 for (unsigned i = 0; i \u003c vSurface.size(); i++) { int tempP1 = vSurface[i].point1, tempP2 = vSurface[i].point2, tempP3 = vSurface[i].point3, tempNor = vSurface[i].normal; triangle.vertex1 = vec3(vVertices[tempP1-1].x, vVertices[tempP1-1].y, vVertices[tempP1-1].z); triangle.vertex2 = vec3(vVertices[tempP2-1].x, vVertices[tempP2-1].y, vVertices[tempP2-1].z); triangle.vertex3 = vec3(vVertices[tempP3-1].x, vVertices[tempP3-1].y, vVertices[tempP3-1].z); triangle.nor = vec3(vNormal[tempNor-1].x, vNormal[tempNor-1].y, vNormal[tempNor-1].z); vTriangle.push_back(triangle); } 試著印出這個 obj 檔案的第一個 triangle 的資料 triangle data vertex 1: (-0.5 -0.5 1) vertex 2: (0.5 -0.5 1) vertex 3: (-0.5 -0.5 0) normal: (0 -1 0) 成功！ ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:2:0","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"mtl 格式 newmtl Reflection001 Ns 8.0000 Ni 2.5000 d 1.0000 illum 2 Ka 0.0000 0.0000 0.0000 Kd 0.5080 0.5080 0.5080 Ks 0.2000 0.2000 0.2000 Ke 0.1000 0.1000 0.1000 Ka: 材質的陰影色 ambient color Kd: 材質本身的顏色 diffuse color Ks: 材質的鏡面光 specular color，若設為 Ks 0.000 0.000 0.000 則為無反光。 Ke: 材質的放射光 emissive color，物體自己會發光 Ns: 反射係數，範圍從 0 到 1000 Ni: 折射值，範圍從 0.001 到 10，若值為 1.0，光線通過時不會偏移。 d / Tr: 材質可以是透明的，範圍從 0.0 到 1.0，數值愈低，表示背景越明顯。 illum: 光照模型 illumination 色彩開，陰影色關 色彩開，陰影色開 鏡面光開 反射開，光線追蹤開 透明： 玻璃開 反射：光線追蹤開 反射：菲涅爾衍射開，光線追蹤開 透明：折射開 反射：菲涅爾衍射關，光線追蹤開 透明：折射開 反射：菲涅爾衍射開，光線追蹤開 反射開，光線追蹤關 透明： 玻璃開 反射：光線追蹤關 投射陰影於不可見表面 ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:3:0","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Graphics"],"content":"Reference pcd，obj，mtl 檔案格式解析 (C++\\openGL)讀取.obj 模型檔 obj + mtl 格式 ","date":"2019-06-05","objectID":"/posts/graphics/graphics-load-obj-mtl/:4:0","tags":["graphics","C++"],"title":"【圖學】讀取 .obj 和 .mtl 檔案","uri":"/posts/graphics/graphics-load-obj-mtl/"},{"categories":["Computer System"],"content":"上一篇 我們知道只要下了 g++ -o myLord.exe myLord.cpp myLord 這兩行指令就能印出想印的文字。 ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:0:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"編譯系統 每一行 C++ 的文字都會被電腦編譯成低階的機器語言1，然後再以可以直接執行的格式打包，最後以二進位的格式封裝保存。 一系列工作都是由 GCC 編譯器所完成的，總共又可分為四個階段：預處理器、編譯器、組譯器、連結器，它們構成了編譯系統 complication system。 下為範例檔，歡迎各位跟著動手試試看！ // file name: myLord.cpp #include \u003ciostream\u003e #define DEBUG #define SIZE 10 using namespace std; int main() { #ifdef DEBUG cout \u003c\u003c \"DEBUG MODE is On.\" \u003c\u003c endl; #else cout \u003c\u003c \"Your Majesty, my Lord.\" \u003c\u003c endl; #endif if(size\u003e5) { cout \u003c\u003c size \u003c\u003c endl; } return 0; } ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:1:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"Preprocess 預處理 g++ -E myLord.cpp -o myLord.i 負責處理編譯之前的工作，原則上就是字串代換的過程，大致分為三個： 引入 #include \u003ciostream\u003e 以 #include 開頭的明令會告訴預處理器讀取其他 .h 檔案的內容。 處理條件編譯 #define DEBUG 以 #define、#ifdef、#ifndef、#if、#else、#endif 等等方式設計條件判斷，阻止某些部分的程式碼執行。 #ifndef 通常我們新增一個標頭檔案 .h 時，會加上 guard： #ifndef SAMPLE_H #define SAMPLE_H ... #endif /* SAMPLE_H */ 但若是原始檔中出現兩個 SAMPLE_H 的話，會造成巨集名稱衝突，加上 #pragma once 有相同效果，卻不會再產生衝突。 將 macro 代換成程式碼片段 (code snippet) #define SIZE 10 或是走火入魔一點 #define MAX(a, b) ((a) \u003e (b) ? (a) : (b)) 對了，記得 macro 要把「所有」變數一一括起來，以免發生奇怪的錯誤。 另外，還有一些是和程式相關的 macro： __LINE__：目前在程式中的行數 __FILE__：檔案名稱 __DATE__：(前置處理器)執行的日期 __TIME__：(前置處理器)執行的時間 cout \u003c\u003c endl \u003c\u003c __FILE__; cout \u003c\u003c endl \u003c\u003c __LINE__; cout \u003c\u003c endl \u003c\u003c __DATE__ \u003c\u003c \" \" \u003c\u003c __TIME__; D:\\Project\\find\\main.cpp 61 Feb 18 2019 21:58:20 myLord.i 檔的內容大部分都是環境設定變數和函式庫路徑 ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:2:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"Compile 編譯 g++ -S myLord.i 編譯器將 .i 檔翻譯成 .s 檔，.s 檔包含完整的低階的組合語言程式，組合語言的優點在於不同高階語言能夠經由不同編譯器得到相同的輸出組合語言2，例如：C 和 Fortran 都會被編譯成組合語言。 這個時候，編譯器也會幫我們檢查語法上的錯誤！ myLord.s 檔中， _main: 後每個句子都代表一條低階機器語言指令 ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:3:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"Assemble 組譯 g++ -c myLord.s myLord.o 再來，組譯器會把 myLord.s 翻譯成機器語言，把指令打包成一個 relocatable object program 格式，並將結果保存在 myLord.o 中。 myLord.o 是一個二進位文件，無法在文字編輯器中打開。 ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:4:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"Link 連結 # 只有單一檔案 g++ -o myLord myLord.o # 有複數檔案 g++ -o myLord myLord.o a.o b.o c.o d.o e.o 在 myLord.cpp 中，我們使用了 cout 函數，而這個函數存放在 iostream.o 這個已經預先編譯好的文件中，而這個文件必須合併到 myLord.o 中，我們才能順利的印出文字，這就是 Linker 的工作。 myLord 執行檔運作時，iostream.o 會被 load 到記憶體中，由系統執行。 ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:5:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"Reference https://opensourcedoc.com/c-programming/preprocessor/ http://blog.udn.com/chungchia/3327025 機器語言 wiki ↩︎ 組合語言 組合語言零基礎入門 ↩︎ ","date":"2019-02-18","objectID":"/posts/cpp/compile_my_cpp_with_g++_3/:6:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (3) - 翻譯課","uri":"/posts/cpp/compile_my_cpp_with_g++_3/"},{"categories":["Computer System"],"content":"繼 上一篇 安裝完成 MinGW 後，我們先來試試看印出字串 Your Majesty, my Lord. // file name: myLord.cpp #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Your Majesty, my Lord.\" \u003c\u003c endl; return 0; } ","date":"2019-02-11","objectID":"/posts/cpp/compile_my_cpp_with_g++_2/:0:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (2) - 編譯初心者","uri":"/posts/cpp/compile_my_cpp_with_g++_2/"},{"categories":["Computer System"],"content":"1 接著，打開 cmd，進入剛才存放 myLord.cpp 的資料夾 g++ myLord.cpp 可以看到新增了一個 a.exe 檔案 執行這個 exe 檔案，輸入檔案名稱： a 馬上會印出 Your Majesty, my Lord. ","date":"2019-02-11","objectID":"/posts/cpp/compile_my_cpp_with_g++_2/:1:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (2) - 編譯初心者","uri":"/posts/cpp/compile_my_cpp_with_g++_2/"},{"categories":["Computer System"],"content":"2 若是我們希望產生的執行檔名稱能夠變成喜歡的名稱，在前面加上 -o 和命名即可。 g++ -o myLord.exe myLord.cpp myLord 也會印出 Your Majesty, my Lord. ","date":"2019-02-11","objectID":"/posts/cpp/compile_my_cpp_with_g++_2/:2:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (2) - 編譯初心者","uri":"/posts/cpp/compile_my_cpp_with_g++_2/"},{"categories":["Computer System"],"content":"3 我們有大一點的 Project 要執行時，會有很多個檔案需要編譯，通常我們會這麼做： g++ -o servants.exe gardeners.cpp laundress.cpp butler.cpp housemaids.cpp 怕其中一個檔案有問題，通常我們會一個一個檔案進行組譯，之後再將它們連結起來。 # 一一組譯 g++ -c gardeners.cpp g++ -c laundress.cpp g++ -c butler.cpp g++ -c housemaids.cpp # 全部的 .o 檔要 link 起來 g++ -o servants.exe gardeners.o laundress.o butler.o housemaids.o ","date":"2019-02-11","objectID":"/posts/cpp/compile_my_cpp_with_g++_2/:3:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (2) - 編譯初心者","uri":"/posts/cpp/compile_my_cpp_with_g++_2/"},{"categories":["Computer System"],"content":"Reference https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html ","date":"2019-02-11","objectID":"/posts/cpp/compile_my_cpp_with_g++_2/:4:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (2) - 編譯初心者","uri":"/posts/cpp/compile_my_cpp_with_g++_2/"},{"categories":["Computer System"],"content":"安裝 MinGW https://sourceforge.net/projects/mingw/ ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:0:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"1 綠色的 Download 按下去，mingw-get-setup.exe 就會開始下載。 ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:1:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"2 打開 mingw-get-setup.exe，在 Basic Setup 中，選取 mingw32-base-bin 和 mingw32-gcc-g++-bin ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:2:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"3 選取完畢後，點擊左上角的 Installation，並 Apply Changes 後，就會開始下載，視網路速度，可能要花個幾分鐘 ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:3:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"4 進入 windows 的「環境變數設定」 (直接在功能表內直接搜尋也可以)，在系統環境變數的 Path 中加入路徑： C:\\MinGW\\bin ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:4:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"5 或是想要偷懶的話，可以在開啟 cmd 時，右鍵「以系統管理員身分執行」，直接設定路徑： setx /m PATH \"C:\\MinGW\\bin;%PATH%\" ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:5:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"6 理論上到這邊就完成 gcc 的安裝，輸入： g++ -v 出現以下文字，代表安裝成功，恭喜恭喜！ COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=c:/mingw/bin/../libexec/gcc/mingw32/9.2.0/lto-wrapper.exe gcc version 9.2.0 (MinGW.org GCC Build-2) 如果沒有出現 gcc version 的文字，代表安裝失敗，像是出現這樣的文字： 'g++' 不是內部或外部命令 怒，我們的起點就是比較艱難 QQ ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:6:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Computer System"],"content":"7 回到剛才安裝的 C:\\MinGW\\bin 資料夾，直接下載 gcc cd MinGW/bin mingw-get install gcc g++ 就會開始下載文件囉，再次輸入 g++ -v 可以開始 gcc 之旅了！ Refernce: http://www.codebind.com/cprogramming/install-mingw-windows-10-gcc/ https://stackoverflow.com/questions/19287379/how-do-i-add-to-the-windows-path-variable-using-setx-having-weird-problems ","date":"2019-02-04","objectID":"/posts/cpp/compile_my_cpp_with_g++/:7:0","tags":["MinGW","windows 10","compile","c++"],"title":"不靠 IDE 自己編譯 C++ (1) - 安裝 MinGW 指南","uri":"/posts/cpp/compile_my_cpp_with_g++/"},{"categories":["Leetcode"],"content":"題目 Problem A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the $i^{th}$ student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the $i^{th}$ student in line (0-indexed). Return the number of indices where heights[i] != expected[i]. Example 1: Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2: Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3: Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. Constraints: 1 $\\leq$ heights.length $\\leq$ 100 1 $\\leq$ heights[i] $\\leq$ 100 ","date":"2019-01-07","objectID":"/posts/leetcode/leetcode_1051_height_checker/:1:0","tags":["array","sorting","counting sort","easy","c++"],"title":"LeetCode 1051. Height Checker 解題紀錄","uri":"/posts/leetcode/leetcode_1051_height_checker/"},{"categories":["Leetcode"],"content":"想法 將現在 heights array 複製一份到 sorted array 對 sorted array 進行從小到大的排序 再一一比對每個元素是否相同 ","date":"2019-01-07","objectID":"/posts/leetcode/leetcode_1051_height_checker/:2:0","tags":["array","sorting","counting sort","easy","c++"],"title":"LeetCode 1051. Height Checker 解題紀錄","uri":"/posts/leetcode/leetcode_1051_height_checker/"},{"categories":["Leetcode"],"content":"解法 int heightChecker(vector\u003cint\u003e\u0026 heights) { // 複製一份到 sorted vector\u003cint\u003e sorted = heights; // 對 sorted 進行排序 sort(sorted.begin(), sorted.end()); // 統計同位置元素值不同的次數 auto ans = 0; // 一一對照 sorted 和 heights 同位置之值 for(auto i=0; i\u003csorted.size(); i++) { if(sorted[i]!=heights[i]) { ans++; } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2019-01-07","objectID":"/posts/leetcode/leetcode_1051_height_checker/:3:0","tags":["array","sorting","counting sort","easy","c++"],"title":"LeetCode 1051. Height Checker 解題紀錄","uri":"/posts/leetcode/leetcode_1051_height_checker/"},{"categories":["Leetcode"],"content":"題目 Problem Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number. Example 1: Input: nums = [3,2,1] Output: 1 Explanation: The first distinct maximum is 3. The second distinct maximum is 2. The third distinct maximum is 1. Example 2: Input: nums = [1,2] Output: 2 Explanation: The first distinct maximum is 2. The second distinct maximum is 1. The third distinct maximum does not exist, so the maximum (2) is returned instead. Example 3: Input: nums = [2,2,3,1] Output: 1 Explanation: The first distinct maximum is 3. The second distinct maximum is 2 (both 2’s are counted together since they have the same value). The third distinct maximum is 1. Constraints: 1 $\\leq$ nums.length $\\leq 10^4$ $-2^{31} \\leq$ nums[i] $\\leq 2^{31} - 1$ Follow up: Can you find an $O(n)$ solution? ","date":"2017-01-09","objectID":"/posts/leetcode/leetcode_414_third_maximum_number/:1:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 414. Third Maximum Number 解題紀錄","uri":"/posts/leetcode/leetcode_414_third_maximum_number/"},{"categories":["Leetcode"],"content":"想法 將 nums 中所有元素進行排序，排序後剔除重複的元素。 若 nums.size$\\geq$3 則取得倒數第三大的元素，反之則取最後一個元素(最大的)。 ","date":"2017-01-09","objectID":"/posts/leetcode/leetcode_414_third_maximum_number/:2:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 414. Third Maximum Number 解題紀錄","uri":"/posts/leetcode/leetcode_414_third_maximum_number/"},{"categories":["Leetcode"],"content":"解法 ","date":"2017-01-09","objectID":"/posts/leetcode/leetcode_414_third_maximum_number/:3:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 414. Third Maximum Number 解題紀錄","uri":"/posts/leetcode/leetcode_414_third_maximum_number/"},{"categories":["Leetcode"],"content":"解法一 用 vector 實作 int thirdMax(vector\u003cint\u003e\u0026 nums) { // 排序所有元素 sort(nums.begin(), nums.end()); // ans 放置 nums 中不重複值的元素 vector\u003cint\u003e ans; int former = INT_MAX; for(auto i:nums) { if(i != former) { ans.push_back(i); } former = i; } return ans.size()\u003c3 ? ans[ans.size()-1] : ans[ans.size()-3]; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2017-01-09","objectID":"/posts/leetcode/leetcode_414_third_maximum_number/:3:1","tags":["array","sorting","easy","c++"],"title":"LeetCode 414. Third Maximum Number 解題紀錄","uri":"/posts/leetcode/leetcode_414_third_maximum_number/"},{"categories":["Leetcode"],"content":"解法二 既然要排序又希望 vector 中的元素唯一，那我們應該可以用 set 來實作吧? int thirdMax(vector\u003cint\u003e\u0026 nums) { set\u003cint\u003e top3; for(auto i:nums) { top3.insert(i); // 大於三個元素，捨棄最小的元素 if(top3.size()\u003e3) { top3.erase(top3.begin()); } } // top3.begin(): 倒數第三大 // top3.rbegin(): 倒數第一大 / 最大 return top3.size()==3 ? *top3.begin() : *top3.rbegin(); } Time complexity: $\\mathcal{O}(nlog(3))$. Space complexity: $\\mathcal{O}(n)$. ","date":"2017-01-09","objectID":"/posts/leetcode/leetcode_414_third_maximum_number/:3:2","tags":["array","sorting","easy","c++"],"title":"LeetCode 414. Third Maximum Number 解題紀錄","uri":"/posts/leetcode/leetcode_414_third_maximum_number/"},{"categories":["Leetcode"],"content":"Reference http://www.cplusplus.com/reference/set/set/ ","date":"2017-01-09","objectID":"/posts/leetcode/leetcode_414_third_maximum_number/:4:0","tags":["array","sorting","easy","c++"],"title":"LeetCode 414. Third Maximum Number 解題紀錄","uri":"/posts/leetcode/leetcode_414_third_maximum_number/"},{"categories":["leetcode"],"content":"題目 Problem Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. Example 1: Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints: The input must be a binary string of length 32 Follow up: If this function is called many times, how would you optimize it? ","date":"2017-01-02","objectID":"/posts/leetcode/leetcode_190_reverse_bits/:1:0","tags":["bit manipulation","divide \u0026 conquer","easy","c++"],"title":"LeetCode 190. Reverse Bits 解題紀錄","uri":"/posts/leetcode/leetcode_190_reverse_bits/"},{"categories":["leetcode"],"content":"想法 使用的是 uint32_t 這個 type ","date":"2017-01-02","objectID":"/posts/leetcode/leetcode_190_reverse_bits/:2:0","tags":["bit manipulation","divide \u0026 conquer","easy","c++"],"title":"LeetCode 190. Reverse Bits 解題紀錄","uri":"/posts/leetcode/leetcode_190_reverse_bits/"},{"categories":["leetcode"],"content":"解法 ","date":"2017-01-02","objectID":"/posts/leetcode/leetcode_190_reverse_bits/:3:0","tags":["bit manipulation","divide \u0026 conquer","easy","c++"],"title":"LeetCode 190. Reverse Bits 解題紀錄","uri":"/posts/leetcode/leetcode_190_reverse_bits/"},{"categories":["leetcode"],"content":"解法一 宣告一個 bitset，逐一做 bit swap XOR truth map class Solution { public: uint32_t reverseBits(uint32_t n) { bitset\u003c32\u003e bit(n); for(auto i=0; i\u003c16; i++) { bit[i] = bit[31-i] ^ bit[i]; bit[31-i] = bit[31-i] ^ bit[i]; bit[i] = bit[31-i] ^ bit[i]; } return (uint32_t) bit.to_ulong(); } }; Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2017-01-02","objectID":"/posts/leetcode/leetcode_190_reverse_bits/:3:1","tags":["bit manipulation","divide \u0026 conquer","easy","c++"],"title":"LeetCode 190. Reverse Bits 解題紀錄","uri":"/posts/leetcode/leetcode_190_reverse_bits/"},{"categories":["leetcode"],"content":"解法二 使用 count 1s 的方法，檢查是否為 1。 moving steps class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t ans = 0; for(auto i=0; i\u003c32; i++) { ans = (ans\u003c\u003c1) | ((n\u003e\u003ei)\u00261); } return ans; } }; Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2017-01-02","objectID":"/posts/leetcode/leetcode_190_reverse_bits/:3:2","tags":["bit manipulation","divide \u0026 conquer","easy","c++"],"title":"LeetCode 190. Reverse Bits 解題紀錄","uri":"/posts/leetcode/leetcode_190_reverse_bits/"},{"categories":["leetcode"],"content":"Reference http://blogs.plymouth.ac.uk/embedded-systems/glossary-2/logical-xor-glossary-entry/ ","date":"2017-01-02","objectID":"/posts/leetcode/leetcode_190_reverse_bits/:4:0","tags":["bit manipulation","divide \u0026 conquer","easy","c++"],"title":"LeetCode 190. Reverse Bits 解題紀錄","uri":"/posts/leetcode/leetcode_190_reverse_bits/"},{"categories":["LeetCode"],"content":"題目 Problem Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 $\\leq$ nums.length $\\leq 10^4$ $-10^9 \\leq$ nums[i] $\\leq 10^9$ $-10^9 \\leq$ target $\\leq 10^9$ Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than $\\mathcal{O}(n^2)$ time complexity? ","date":"2016-12-26","objectID":"/posts/leetcode/leetcode_1_two_sum/:1:0","tags":["array","hash table","easy","c++"],"title":"LeetCode 1. Two Sum 解題紀錄","uri":"/posts/leetcode/leetcode_1_two_sum/"},{"categories":["LeetCode"],"content":"想法 天字第一題，可以先跳過(誤) 如果是第一次寫 LeetCode，建議可以複製以下內容用 Online compiler 寫寫看，完成後再把 twoSum funcion 的部分貼到 LeetCode 上。 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { return {}; } int main() { // input vector\u003cint\u003e input = { 2, 7, 11, 15 }; // get the output vector\u003cint\u003e output = twoSum(input, 9); // print the output cout \u003c\u003c \"output: \"; for(auto i:output) { cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } 在 hash table 內尋找想要的 9(target) -2 (目前數字) 為欲尋找的數字 7，若有找到的話，將這個數字傳回 vector 作答；若沒有找到，則將目前數字 2 加入 hash 中，供後人搜尋。 ","date":"2016-12-26","objectID":"/posts/leetcode/leetcode_1_two_sum/:2:0","tags":["array","hash table","easy","c++"],"title":"LeetCode 1. Two Sum 解題紀錄","uri":"/posts/leetcode/leetcode_1_two_sum/"},{"categories":["LeetCode"],"content":"解法 ","date":"2016-12-26","objectID":"/posts/leetcode/leetcode_1_two_sum/:3:0","tags":["array","hash table","easy","c++"],"title":"LeetCode 1. Two Sum 解題紀錄","uri":"/posts/leetcode/leetcode_1_two_sum/"},{"categories":["LeetCode"],"content":"解法一：暴力法 全部的數字全部找過一輪 ❌(TLE) Time complexity: $\\mathcal{O}(n^2)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2016-12-26","objectID":"/posts/leetcode/leetcode_1_two_sum/:3:1","tags":["array","hash table","easy","c++"],"title":"LeetCode 1. Two Sum 解題紀錄","uri":"/posts/leetcode/leetcode_1_two_sum/"},{"categories":["LeetCode"],"content":"解法二：unordered_map class Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { unordered_map\u003cint, int\u003e mp; for(auto i=0; i\u003cnums.size(); i++) { if(mp.find(target-nums[i]) != mp.end()) { return {i, mp[target-nums[i]]}; } else { mp[nums[i]] = i; } } return {}; } }; Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. ","date":"2016-12-26","objectID":"/posts/leetcode/leetcode_1_two_sum/:3:2","tags":["array","hash table","easy","c++"],"title":"LeetCode 1. Two Sum 解題紀錄","uri":"/posts/leetcode/leetcode_1_two_sum/"},{"categories":["LeetCode"],"content":"完整 C++ 實驗 附上可以直接在 Online compiler 跑的 code，可以先試試看在 LeetCode 介面的使用： #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cunordered_map\u003e using namespace std; vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { unordered_map\u003cint, int\u003e mp; if(!nums.size()) { return {}; } for(auto i=0; i\u003cnums.size(); i++) { if(mp.find(target - nums[i]) != mp.end()) { return {i, mp[target - nums[i]]}; } else { mp[nums[i]] = i; } } return {}; } int main() { vector\u003cint\u003e input = { 2, 7, 11, 15 }; vector\u003cint\u003e output = twoSum(input, 9); // print the output cout \u003c\u003c \"output: \"; for(auto i:output) { cout \u003c\u003c i \u003c\u003c \" \"; } return 0; } ","date":"2016-12-26","objectID":"/posts/leetcode/leetcode_1_two_sum/:3:3","tags":["array","hash table","easy","c++"],"title":"LeetCode 1. Two Sum 解題紀錄","uri":"/posts/leetcode/leetcode_1_two_sum/"},{"categories":["other"],"content":"清潔成分有夠複雜，很多日韓媽媽網紅會在 Instagram 分享用法，但每次要打掃的時候就要在相簿裡面一直找截圖，在這邊整理一下~ 各種清潔成分倒進預先準備好的噴霧瓶(空的酒精噴瓶)，依照比例調製，搖一搖確定均勻溶解後就能使用啦。 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:0:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"懶人包知識： 酸鹼性　pH 值 鹽酸 0 / 檸檬酸 2 / 水 7 / 小蘇打 8 / 倍半碳酸鈉 10 / 過碳酸鈉 11 不用硬背，重點是比較關係 酸性清潔劑就要對付鹼性油汙，鹼性清潔劑則是對付酸性油汙 酸性油汙：油垢、皮脂 鹼性油汙：水垢、尿垢 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:1:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"檸檬酸 用途：去除水漬皂垢、殘渣腥味 使用位置：浴缸皂垢、馬桶尿垢、流理臺、飲水機內部、廚餘濾籃 廚房水龍頭如果是上下開關的類型，可以噴檸檬酸水後，用牙刷仔細刷除縫隙卡著的水+油垢，開關才不會久了變卡。 要清潔廁所磁磚、玻璃和鏡子時， 先用廚房紙巾覆蓋要清潔的位置 將檸檬酸水「完全」噴濕紙巾，噴到紙巾自己可以黏在表面上的程度 以保鮮膜覆蓋紙巾，減少水氣的蒸發 視水垢的嚴重程度，增加步驟。 等 1 小時左右，將報紙和紙巾去除，用小刷子ㄏㄨㄟ ˊ 過去並沖水，就能獲得一個乾淨溜溜的浴室啦！ 環保秘方 如果家裡有多餘的水果 (就是中秋節吃不完的柚子)，可以切片用湯匙擠汁加水稀釋，廁所還有果香味😙 對了，通常會擠一小瓶放冰箱，需要的時候再加水使用，做多少用多少。 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:2:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"過碳酸鈉 用途：去除黴菌、漂白殺菌、茶垢污漬、鍋底焦痕 使用位置：浴缸、廁所磁磚、砧板、洗衣機、鍋子 屬於氧系漂白劑的一種，洗衣精裡面就有它的存在，無毒無味，但建議使用時戴手套。 遇水會分解成過氧化氫和碳酸鈉，溶解度較小蘇打粉好，水溫越高，漂白效果越好。 消毒去黴菌 是滴，廁所就是那摸麻煩。 如果長時間沒有清潔的廁所很容易長出黴菌，漱口杯底部如果沒有晾乾，也很容易發霉長出黑黑紅紅的斑點，黴菌對皮膚有害，要根治需要非常長的時間 (Google 黴菌 皮膚病)。 參照前面用檸檬酸幫廁所敷面膜的步驟，將過碳酸鈉水噴上去。 去除衣物染色、污漬 浸泡衣服的部分，先將欲清潔的物品放在盆子或塑膠袋裡面，加入過碳酸鈉後，注入熱水，物品四周會開始冒出泡泡，切記勿急勿荒，浸泡 4~8 小時後取出，以清水沖洗晾乾即可。 靠著過碳酸鈉把染色的純白毛衣、背了幾年的帆布包、小屁孩抱了 10 年的兔寶寶，洗得乾淨溜溜，非常推薦。 去除重油垢 步驟同浸泡衣物，小心鋁製品等部分金屬、羊毛、蠶絲不能泡之外，其他杯碗瓢盆各種想浸泡的東西都能泡。 在清抽油煙機時，濾網取下後，塑膠蓋子上的重油汙可以拿不要的塑膠袋浸泡過碳酸鈉水，浸泡完畢後將水倒掉，油膩膩的塑膠袋可以直接丟進垃圾桶，方便很多唷。 生活必備 Tip 將過碳酸鈉和水以 1:10 的比例調和，每天洗完澡後將全室完整噴灑，不刷不沖洗也沒關係，這樣可以防霉及抗菌。 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:3:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"重曹 = 小蘇打 = 碳酸氫鈉 = NaHCO3 用途：日常清洗、除臭、研磨 使用位置：清洗餐具、清洗水果 完全不建議把小蘇打粉丟進洗衣機！ 要溶解小蘇打粉需要 65 度 C 以上，這麼高溫會傷衣料，平常也不會用那麼高的溫度來洗衣服。 若未完全洗乾淨，皮膚接觸小蘇打就類似於用手沾肥皂後沒洗乾淨，很痛苦啊。 平時清潔不大會直接用它，反而會作為研磨劑，混合過碳酸鈉成為「倍半碳酸鈉」。 另外，小蘇打的去濕去味效果不錯，可以用透氣的不織布(茶包濾網)盛裝，放在鞋櫃、衣櫃等濕氣和味道比較重的地方做除濕除臭。 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:4:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"倍半碳酸鈉 用途：油漬髒汙、污漬除臭 使用位置：微波爐、冰箱、鍋具焦垢(no 鋁鍋)、抽油煙機、瓦斯爐、領口袖子、皮脂髒污 碳酸鈉和小蘇打粉一比一混合即可。 分解油脂、汙垢、蛋白脂的效果都很好，清洗沾到經血的衣物、被單都沒問題。 幾乎可以比照過碳酸鈉的用法，只要小心，倍半碳酸鈉侵蝕性更高，手套絕對要戴。 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:5:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"電解水 用途：油漬髒汙、污漬除臭 使用位置：家具、流理臺、嬰兒用品 視為懶人版的過碳酸鈉，不用再一次以清水擦拭/沖洗，相當方便，成本也比較高。 可用在家具、地板、玩具等平常小孩會親密接觸的地方，由於以上所有的清潔劑都需要再用清水沖過，怕萬一沒清乾淨被吃下肚就麻煩了 ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:6:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["other"],"content":"加碼補充一個 由於外宿，排水孔如果被頭髮之類的異物卡住，實在不想徒手挖別人的垃圾，推薦小林排水管泡沫清潔劑，我是在日本買的，希望未來台灣代購也會進口。 瓶口有一個網，擠的時候要比較用力一點，擠出的清潔劑呈現泡泡狀，將瓶口伸進排水孔，讓泡泡佈滿整個水管。 以前都倒顆粒鹽酸，由於鹽酸有重量，一倒下去就會掉到排水管底部，水管的上半部還是需要自己動手清理 QQ 等大約 2 小時之後，就可以用大量清水清潔囉！ ","date":"2016-01-25","objectID":"/posts/cleaning_my_room_keep_calm/:7:0","tags":["整理","生活"],"title":"【生活】清潔成分整理","uri":"/posts/cleaning_my_room_keep_calm/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2: Input: numRows = 1 Output: [[1]] Constraints: 1 $\\leq$ numRows $\\leq$ 30 ","date":"2015-02-23","objectID":"/posts/leetcode/leetcode_118_pascals_triangle/:1:0","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 118. Pascal's Triangle 解題紀錄","uri":"/posts/leetcode/leetcode_118_pascals_triangle/"},{"categories":["leetcode"],"content":"想法 預設每個 row 的元素都是 1。 由前一個 row 獲得位置的值：從每個 row 第二個元素起與前一 row 同位置與前一位置的值相加。 ","date":"2015-02-23","objectID":"/posts/leetcode/leetcode_118_pascals_triangle/:2:0","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 118. Pascal's Triangle 解題紀錄","uri":"/posts/leetcode/leetcode_118_pascals_triangle/"},{"categories":["leetcode"],"content":"解法 vector\u003cvector\u003cint\u003e\u003e generate(int numRows) { vector\u003cvector\u003cint\u003e\u003e ans; for(auto i=0; i\u003cnumRows; ++i) { vector\u003cint\u003e row(i+1, 1); for(auto j=1; j\u003ci; ++j) { row[j] = ans[i-1][j-1] + ans[i-1][j]; } ans.push_back(row); } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2015-02-23","objectID":"/posts/leetcode/leetcode_118_pascals_triangle/:3:0","tags":["array","dynamic programming","easy","c++"],"title":"LeetCode 118. Pascal's Triangle 解題紀錄","uri":"/posts/leetcode/leetcode_118_pascals_triangle/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer array nums of 2$n$ integers, group these integers into $n$ pairs $(a_1, b_1), (a_2, b_2), …, (a_n, b_n)$ such that the sum of $min(a_i, b_i)$ for all $i$ is maximized. Return the maximized sum. Example 1: Input: nums = [1,4,3,2] Output: 4 Explanation: All possible pairings (ignoring the ordering of elements) are: $(1, 4), (2, 3)$ -\u003e $min(1, 4) + min(2, 3)$ = 1 + 2 = 3 $(1, 3), (2, 4)$ -\u003e $min(1, 3) + min(2, 4)$ = 1 + 2 = 3 $(1, 2), (3, 4)$ -\u003e $min(1, 2) + min(3, 4)$ = 1 + 3 = 4 So the maximum possible sum is 4. Example 2: Input: nums = [6,2,6,5,1,2] Output: 9 Explanation: The optimal pairing is $(2, 1), (2, 5), (6, 6)$. $min(2, 1) + min(2, 5) + min(6, 6)$ = 1 + 2 + 6 = 9. Constraints: 1 $\\leq$ n $\\leq$ 104 nums.length = 2 $\\times$ n $-10^4 \\leq$ nums[i] $\\leq 10^4$ ","date":"2015-01-05","objectID":"/posts/leetcode/leetcode_561_array_partition_i/:1:0","tags":["array","greedy","sorting","counting sort","easy","c++"],"title":"LeetCode 561. Array Partition I 解題紀錄","uri":"/posts/leetcode/leetcode_561_array_partition_i/"},{"categories":["leetcode"],"content":"想法 希望從 input array 中得到兩兩 $min$ 並且想加為最大值的情況： [1, 4, 3, 2] 應該在排序後的 array 中，第一項和第二項做 $min$，再依序相加： [1, 2, 3, 4] 已知現在 array 為由小至大的排序， 又發現第一項和第二項做 $min$ 前，已經可以預知第一項必為 $min$ 值。 故以此推論，只要把排序過後的第一項、第三項等相加，即可獲得所求。 [1, 2, 3, 4] ^ ^ ","date":"2015-01-05","objectID":"/posts/leetcode/leetcode_561_array_partition_i/:2:0","tags":["array","greedy","sorting","counting sort","easy","c++"],"title":"LeetCode 561. Array Partition I 解題紀錄","uri":"/posts/leetcode/leetcode_561_array_partition_i/"},{"categories":["leetcode"],"content":"解法 int arrayPairSum(vector\u003cint\u003e\u0026 nums) { // 將 input array 由小排到大 sort(nums.begin(), nums.end()); // 預設 max 為 0 // ps: 當 nums.size()==0 時，return 也是 0 auto ans = 0; // 只要將每組數字的前項相加即可獲得 max for(auto i=0; i\u003cnums.size(); i+=2) { ans += nums[i]; } return ans; } Time complexity C++ sort 函數的 complexity 為 $O(nlog(n))$ Time complexity: $\\mathcal{O}(nlog(n))$. Space complexity: $\\mathcal{O}(n)$. ","date":"2015-01-05","objectID":"/posts/leetcode/leetcode_561_array_partition_i/:3:0","tags":["array","greedy","sorting","counting sort","easy","c++"],"title":"LeetCode 561. Array Partition I 解題紀錄","uri":"/posts/leetcode/leetcode_561_array_partition_i/"},{"categories":["leetcode"],"content":"Reference https://en.wikipedia.org/wiki/Sort_(C%2B%2B) ","date":"2015-01-05","objectID":"/posts/leetcode/leetcode_561_array_partition_i/:4:0","tags":["array","greedy","sorting","counting sort","easy","c++"],"title":"LeetCode 561. Array Partition I 解題紀錄","uri":"/posts/leetcode/leetcode_561_array_partition_i/"},{"categories":["Computer System"],"content":"變數宣告時給的記憶體空間並非連續，而是每 data alignment 視為一「節」，一節有 4 個位置 (bytes) struct data_alignment { char a1; // 1 byte short a2; // 2 bytes int a3; // 4 bytes }; 1 + 2 + 4 = 7 bytes，但實際結果卻是 12 bytes 第一節放置 a1，占用 1 個 byte，剩餘 3 個 bytes 閒置 第二節放置 a2，占用 2 個 bytes，剩餘 2 個 bytes 閒置 第三節放置 a3，完全占滿 4 個 bytes 實際上應該是在閒置的空間加上 char padding (閒置 bytes 數) 可以修改 data alignment #pragma pack(push) #pragma pack(1) struct data_alignment_adjusted { char a1; // 1 byte short a2; // 2 bytes int a3; // 4 bytes }; #pragma pack(pop) pragma pack(1) 設定一節長度，長度最長以 struct 中最大的數值為主 (ex: 1, 2, 4) 這樣一來，每一節的長度設定為 1 bytes，便不會有閒置空間，實際使用 7 bytes。 ","date":"2014-07-28","objectID":"/posts/cpp/cpp_data_alignment/:0:0","tags":["compile","c++"],"title":"【C++】Data Alignment 資料對齊","uri":"/posts/cpp/cpp_data_alignment/"},{"categories":["Computer System"],"content":"#include \u003ciostream\u003e or #include \u003ciostream.h\u003e 在第一堂 c++課程大概都會教：記得要在最前面打上一個 #，而後面 include ，方便一些資料進出程式。 但是!!!! 當要使用 cout 的時候，又叫你回到前方加上 using namespace std… ","date":"2014-07-21","objectID":"/posts/cpp/cpp_iostream-vs-iostreamh/:0:0","tags":["compile","c++"],"title":"【C++】\u003ciostream\u003e vs \u003ciostream.h\u003e","uri":"/posts/cpp/cpp_iostream-vs-iostreamh/"},{"categories":["Computer System"],"content":"\u003ciostream\u003e 屬於標準輸入輸出流，歸 C++ 所管，需要使用到命令空間 大致上分成三種寫法： #include \u003ciostream\u003e // 引入標準 c++ 資源庫 int main() { string hi(\"我會使用c++標準庫\"); std::cout \u003c\u003c hi; // 每一句我都會記得打這種很難打的格式鳩咪 std:: } #include \u003ciostream\u003e // 引入標準 c++ 資源庫 using namespace std; // 吃 C++ 就要乖乖使用命名空間 int main() { string hi(\"我會使用c++標準庫\"); cout \u003c\u003c hi; return 0; }; #include \u003ciostream\u003e // 引入標準 c++ 資源庫 using std::cout; // 先宣告看到 cout 一律下跪(x) 幫他加 std::(o) int main() { string hi(\"我會使用c++標準庫\"); cout \u003c\u003c hi; } ","date":"2014-07-21","objectID":"/posts/cpp/cpp_iostream-vs-iostreamh/:1:0","tags":["compile","c++"],"title":"【C++】\u003ciostream\u003e vs \u003ciostream.h\u003e","uri":"/posts/cpp/cpp_iostream-vs-iostreamh/"},{"categories":["Computer System"],"content":"\u003ciostream.h\u003e \u003ciostream.h\u003e 屬於非標準輸入輸出流，.h 結尾的標頭檔，直接繼承 C 語言的標準庫，空間定義之類的什麼都不用加！ #include \u003ciostream.h\u003e // 引入非標準輸入輸出流 int main() { string hi(\"我會使用c++標準庫\"); cout \u003c\u003c hi; } ","date":"2014-07-21","objectID":"/posts/cpp/cpp_iostream-vs-iostreamh/:2:0","tags":["compile","c++"],"title":"【C++】\u003ciostream\u003e vs \u003ciostream.h\u003e","uri":"/posts/cpp/cpp_iostream-vs-iostreamh/"},{"categories":["leetcode"],"content":"題目 Problem Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums. Example 1: Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Example 2: Input: nums = [1,1] Output: [2] Constraints: n == nums.length 1 $\\leq$ n $\\leq$ $10^5$ 1 $\\leq$ nums[i] $\\leq$ n Follow up: Could you do it without extra space and in $O(n)$ runtime? You may assume the returned list does not count as extra space. ","date":"2014-07-14","objectID":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/:1:0","tags":["array","hash table","unordered map","easy","c++"],"title":"LeetCode 448. Find All Numbers Disappeared in an Array 解題紀錄","uri":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/"},{"categories":["leetcode"],"content":"想法 輸入 vector 有 n 個 elements 就代表 elements 範圍由 [1, n]； 例如：input vector 有三個 elements 表示其範圍是 [1, 3]。 需要知道目前 vector 的 size，再尋找各個 elements 中是否有依序出現由 1 到 n 的數字。 ","date":"2014-07-14","objectID":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/:2:0","tags":["array","hash table","unordered map","easy","c++"],"title":"LeetCode 448. Find All Numbers Disappeared in an Array 解題紀錄","uri":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/"},{"categories":["leetcode"],"content":"解法 ","date":"2014-07-14","objectID":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/:3:0","tags":["array","hash table","unordered map","easy","c++"],"title":"LeetCode 448. Find All Numbers Disappeared in an Array 解題紀錄","uri":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/"},{"categories":["leetcode"],"content":"解法一 最直覺的方法是將 input vector 的元素全掃過一輪，填入 unordered map，最後再檢查是否範圍內的各數字都有出現，若未出現，則插入 ans vector。 vector\u003cint\u003e findDisappearedNumbers(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e ans; // 建立檢查數字是否存在的 unordered_map unordered_map\u003cint, bool\u003e mp; // 一一掃過所有的元素，並在對應數值設為 1 for(auto i:nums) { mp[i] = 1; } // 檢查 mp 中，若該數字不存在則 push_back for(auto i=1; i\u003c=nums.size(); i++) { if(mp[i] == 0) { ans.push_back(i); } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(n)$. ","date":"2014-07-14","objectID":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/:3:1","tags":["array","hash table","unordered map","easy","c++"],"title":"LeetCode 448. Find All Numbers Disappeared in an Array 解題紀錄","uri":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/"},{"categories":["leetcode"],"content":"解法二 若該位置的數字已經出現過，將該位置的值改為負數。 當全部的元素接已經完成前一步驟，該位置若 $\u003e0$，就代表這個數字沒出現過。 例如：最後發現 nums[2] 到結束時仍為 10，表示 2+1=3 這個數字沒有出現過。 下有完整舉例 input array： [0] [1] [2] [3] [4] [5] [6] [7] 4 3 2 7 8 2 3 1 nums[0] = 4 ➙ 把第四個元素 nums[3] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 3 2 -7 8 2 3 1 🚩 nums[1] = 3 ➙ 把第三個元素 nums[2] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 3 -2 -7 8 2 3 1 🚩 nums[2] = -2，我們要看的是 abs(-2) = 2 ➙ 把第二個元素 nums[1] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 -3 -2 -7 8 2 3 1 🚩 nums[3] = -7，我們要看的是 abs(-7) = 7 ➙ 把第七個元素 nums[6] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 -3 -2 -7 8 2 -3 1 🚩 nums[4] = 8 ➙ 把第八個元素 nums[7] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 -3 -2 -7 8 2 -3 -1 🚩 nums[5] = 2 ➙ 把第三個元素 nums[1] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 -3 -2 -7 8 2 -3 -1 🚩 nums[6] = -3，我們要看的是 abs(-3) = 3 ➙ 把第七個元素 nums[2] 的數值變成負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] 4 -3 -2 -7 8 2 -3 -1 🚩 nums[7] = -1，我們要看的是 abs(-1) = 1 ➙ 把第七個元素 nums[0] 的數值維持負數 🏷️ [0] [1] [2] [3] [4] [5] [6] [7] -4 -3 -2 -7 8 2 -3 -1 🚩 最後發現 nums[4] 和 nums[5] 兩個元素的值仍為正數，表示 4+1=5 和 5+1=6 兩數字都沒有出現過。 vector\u003cint\u003e findDisappearedNumbers(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e ans; for(auto i=0; i\u003cnums.size(); i++) { int n = abs(nums[i])-1; if(nums[n] \u003e 0) { nums[n] *= -1; } } for(auto i=0; i\u003cnums.size(); i++) { if(nums[i]\u003e0) { ans.push_back(i+1); } } return ans; } Time complexity: $\\mathcal{O}(n)$. Space complexity: $\\mathcal{O}(1)$. 這個方法好猛！！！ ","date":"2014-07-14","objectID":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/:3:2","tags":["array","hash table","unordered map","easy","c++"],"title":"LeetCode 448. Find All Numbers Disappeared in an Array 解題紀錄","uri":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/"},{"categories":["leetcode"],"content":"Reference https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92958/c%2B%2B-solution-O(1)-space ","date":"2014-07-14","objectID":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/:4:0","tags":["array","hash table","unordered map","easy","c++"],"title":"LeetCode 448. Find All Numbers Disappeared in an Array 解題紀錄","uri":"/posts/leetcode/leetcode_448_find_all_numbers_disappeared_in_an_array/"},{"categories":["leetcode"],"content":"題目 Problem Given an integer n, return the number of prime numbers that are strictly less than n. Example 1: Input: n = 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Example 2: Input: n = 0 Output: 0 Example 3: Input: n = 1 Output: 0 Constraints: 0 $\\leq$ n $\\leq$ 5 $\\times 10^6$ ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:1:0","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"想法 質數 「質數」有兩個定義： 必為大於 1 的整數 只有兩個因數，一個是 1、一個是自己 100 以內的質數： 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97， 共 25 個。 根據以上定義，我們可以簡單寫出一個 isPrime function 來判斷這個數字是否為質數。 給出一個數字 n，從 2 到 n-1 依序除除看，若能整除，代表這個數字有除了 1 和 n 以外的因數，也就意味著 n 並非質數。 bool isPrime(int n) { if(n \u003c 2) return 0; // 從 2 到 n-1 依序除除看 for(auto i=2; i\u003cn; i++) { if(n%i == 0) { return 0; } } return 1; } 1.215 sec. 現在執行效率有點差，有哪些數字是一看就知道不是質數的數字呢？ 4, 6, 8, 10, 12, 14… 那些偶數，一看就知道它們能被 2 整除，可以排除計算，節省一點時間。 希望能在檢查到偶數時直接回答 false，但是 2 又是質數，返回 n 是否為 2 即可。 因為事先已經檢查過偶數了，接下來的迴圈檢查就可以跳過它們囉，節省一點時間！ bool isPrime(int n) { if(n \u003c 2) return 0; // 若 n=2 則為質數，若為 2 的倍數則否 if(n%2 == 0) return n==2; // 從 3 到 n-1 依序除除看 for(auto i=3; i\u003cn; i++) { if(n%i == 0) { return 0; } } return 1; } 1.215 sec. 好像…沒什麼差別，上面的方法還是依序檢查了 3 到 n-1 ，應該直接在迴圈中跳過 2 才對吧 XD bool isPrime(int n) { if(n \u003c 2) return 0; for(auto i=3; i\u003cn; i+=2) { if(n%i == 0) { return 0; } } return 1; } 0.628 sec. 現在的方法搜尋了 $\\frac{n}{2}$ 次，效能也提升了將近一倍 😙 小結一下，到目前為止的優化，時間複雜度是 isPrime $\\mathcal{O}(n)$ $\\times$countPrimes$ \\mathcal{O}(n^2)=$ $\\mathcal{O}(n^2)$ 又以 36 為例， $36$ $= 1 \\times 36 = 2 \\times 18 = 3 \\times 12$ $= 4 \\times 9 = 6 \\times 6 = 9 \\times 4$ $= 12 \\times 3 = 18 \\times 2 = 36 \\times 1$ 仔細想想，我們在遇到 6 之後，所有的因數組合全部都和前面相同：最後的 $36 \\times 1$ 和第一段 $1 \\times 36$ 是重複的，那麼我們只要計算到 $i \\leq \\sqrt{n}$ 或是 $i \\times i \\leq n$ 就能停止了，後半部都是一模一樣嘛！ bool isPrime(int n) { if(n \u003c 2) return 0; for(auto i=3; i*i\u003c=n; i++) { if(n%i == 0) { return 0; } } return 1; } 0.007 sec. 目前的複雜度是 $\\mathcal{O}(n\\sqrt{n})$ 雖然思考了一段時間，但是還是 Time Limit Exceeded 😢 break \u0026 continue ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:2:0","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"break 在迴圈中執行時，只要 if 條件符合使用 break 的時機，立刻會離開 for/while 迴圈。 #include \u003ciostream\u003e using namespace std; int main() { for(auto i=0; i\u003c6; i++) { if(i==3) { break; } cout \u003c\u003c i \u003c\u003c \", \"; } cout \u003c\u003c \"end\"; return 0; } 0, 1, 2, end ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:2:1","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"continue 在迴圈中執行時，只要 if 條件符合使用 continue 的時機，將會結束本次迴圈，進入下一次 for/while 的條件判斷 (ex: i++) #include \u003ciostream\u003e using namespace std; int main() { for(auto i=0; i\u003c6; i++) { if(i==3) { continue; } cout \u003c\u003c i \u003c\u003c \", \"; } cout \u003c\u003c \"end\"; return 0; } 0, 1, 2, 4, 5, end ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:2:2","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"解法 ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:3:0","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"解法一：Sieve of Eratosthenes 法 預設 1 ~ n-1 所有數字都是質數。 第一輪找到 2，2 是質數，但 2 的倍數則不是質數，所以我們可以剔除 4, 6, 8, 10, 12,… 第二輪找到 3，3 是質數，但 3 的倍數則不是質數，所以我們可以剔除 6, 9, 12,…，由於在第一輪 2 的倍數已經先移除 6 和 12 了，所以節省了相當多的時間。 最後我們再一一清點 isPrime 中有多少質數。 Sieve of Eratosthenes int countPrimes(int n) { if(n\u003c2) return 0; // 預設 n 個數為質數 vector\u003cbool\u003e isPrime(n, 1); // 依序檢查是否為 n 的因數 for(auto i=2; i*i\u003cn; i++) { // 如果這個數字確定是質數 if(isPrime[i]) { // 將 i 的倍數全部標示為「非質數」 for(auto j=i*i; j\u003cn; j+=i) { isPrime[j] = 0; } } } // 計算總共有幾個質數 auto ans = 0; for(auto i=2; i\u003cn; i++) { if(isPrime[i]) ans++; } return ans; } 0.003 sec. Time complexity: $\\mathcal{O}(n log (log(n)))$. Space complexity: $\\mathcal{O}(n)$. ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:3:1","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"解法二 預設 1 ~ n 所有數字都是質數。 第一個數字看到 3，3 是質數，但 3 的倍數不是質數，為了減少計算偶數的計算，3 的奇數倍為 $3 \\times 3$, $3 \\times 5$, $3 \\times 7$, $3 \\times 9$, $3 \\times (2n-1)$：9, 15, 21, 27,… 剩下作法同解法一 int countPrimes(int n) { if(n\u003c2) { return 0; } // 預設 n 個數是質數 vector\u003cbool\u003e prime(n, 1); // 2 本身就是一個質數，因為這個 function 沒有計算偶數的部分，故當作特例 auto ans = 1; // 等同於 i*i \u003c n int upper = sqrt(n); // 依序掃描所有的「奇數」 for(auto i=3; i\u003cn; i+=2) { // 若此數已經不是質數，則逕行檢查下一個數字 if(!prime[i]) { continue; } ans++; // 防止 i^2 溢位 if(i \u003e upper) { continue; } // 每次增加 2*i，讓 j 永遠都是奇數 for(auto j=i*i; j\u003cn; j+=2*i) { prime[j] = 0; } } return ans; } 0.003 sec. Time complexity: $\\mathcal{O}(n log (log(n)))$. Space complexity: $\\mathcal{O}(n)$. ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:3:2","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"},{"categories":["leetcode"],"content":"Reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes https://www.geeksforgeeks.org/sieve-of-eratosthenes/ ","date":"2014-07-07","objectID":"/posts/leetcode/leetcode_204_count_primes/:4:0","tags":["array","math","enumeration","number theory","medium","c++"],"title":"LeetCode 204. Count Primes 解題紀錄","uri":"/posts/leetcode/leetcode_204_count_primes/"}]